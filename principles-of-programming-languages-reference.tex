\documentclass[a4paper,landscape,10pt]{article}

\usepackage{settings}

% TODO: when everything has been written, space correctly the content by breaking the columns via the \breakcolumn command

\begin{document}

\section{Racket}
\begin{multicols*}{2}
  \subsection{Comments}

  \begin{itemize}
    \item single line comment: \iracket{;}
    \item multi-line comment: \iracket{\#| ... |\#}
    \item multi-line comments can be nested
  \end{itemize}

  \begin{lstlisting}[language=Racket]
; single line comment
#|
  multi-line-comment
	can span
	multiple lines
  end of comment
|#
\end{lstlisting}

  \subsection{Datum evaluation}

  \begin{itemize}
    \item \iracket{(quote <datum>)} or \iracket{'<datum>} leaves the datum as-is
    \item \iracket{(unquote <datum>)} or \iracket{,<datum>} is the opposite of \iracket{quote}
    \item \iracket{(quasiquote <datum>)} or \iracket{,@<datum>} allows to apply the unquote where needed
  \end{itemize}

  \begin{lstlisting}[language=Racket]
'(1 2 3); => (1 2 3)
(1 ,(+ 1 1) 3) ; => '(1 2 3)
\end{lstlisting}

  \subsection{Predicates}

  \begin{itemize}
    \item all predicates end with \iracket{?}
    \item checks if a number is even: \iracket{even?}
    \item checks if a number is odd: \iracket{odd?}
    \item check if a datum is true: \iracket{true?}
    \item check if a number is positive: \iracket{positive?}
    \item check if a number is negative: \iracket{negative?}
    \item check if a number is zero: \iracket{zero?}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(even? 2) ; => #t
(odd? 2) ; => #f
(true? #t) ; => #t
\end{lstlisting}

  \subsubsection{Equivalence}

  \begin{itemize}
    \item check if two numbers are equal: \iracket{=}
    \item checks if two objects or numbers are the same: \iracket{eq?}
    \item checks if two objects are the same: \iracket{eqv?}
    \item checks if two objects are the same: \iracket{equal?}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(= 1 1) ; => #t
(eq? 1 1) ; => #t
(eqv? 1 1) ; => #t
(equal? 1 1) ; => #t
\end{lstlisting}

  \subsection{Data types}

  \begin{itemize}
    \item integer: \iracket{9125}
    \item binary: \iracket{#b10001110100101}
    \item octal: \iracket{#o21645}
    \item hexadecimal: \iracket{#x23a5}
    \item real: \iracket{91.25}
    \item rational: \iracket{91/25}
    \item complex: \iracket{91+25i}
    \item boolean: \iracket{#t, #f}
    \item character: \lstinline[language=Racket]!#\A, #\$\lambda$, #\u30BB! % this cannot be changed to a macro because of the special characters
    \item null element: \iracket{'(), null}
    \item lists: \iracket{'(1 2 3)}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(define x 5) ; => x = 5
(define y "Hello, world!") ; => y = "Hello, world!"
(define z #t) ; => z = #t
(define w #\A) ; => w = #\A
null ; => '()
\end{lstlisting}

  \subsubsection{Basic operations}

  \begin{itemize}
    \item all operations are in prefix notation \iracket{(<operator> <operand> ...)}
  \end{itemize}

  \paragraph{Operations on numbers}

  \begin{itemize}
    \item arithmetic operations: \iracket{+}, \iracket{-}, \iracket{*}, \iracket{/}
    \item exponentiation: \iracket{expt}
    \item exponentiation by e: \iracket{exp}
    \item logarithm: \iracket{log}
    \item quotient: \iracket{quotient}
    \item remainder: \iracket{remainder}
    \item largest and smallest of two numbers: \iracket{max}, \iracket{min}
    \item add \(1\): \iracket{add1}
    \item subtract \(1\): \iracket{sub1}
    \item greatest common divisor: \iracket{gcd}
    \item least common multiple: \iracket{lcm}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(+ 1 2 3) ; => 6
(- 1 2 3) ; => -4
(expt 2 3) ; => 8
(exp 2) ; => e ** 2 = 7.38905609893065
(log 10) ; => 2.302585092994046
(quotient 5 2) ; => 2
(remainder 5 2) ; => 1
(max 1 2) ; => 2
(min 1 2) ; => 1
(add1 5) ; => 6
(sub1 5) ; => 4
(gcd 12 18) ; => 6
(lcm 12 18) ; => 36
\end{lstlisting}

  \paragraph{Operations on strings}

  \begin{itemize}
    \item string length: \iracket{string-length}
    \item string append: \iracket{string-append}
    \item string to list: \iracket{string->list}
    \item list to string: \iracket{list->string}
    \item get n-th character: \iracket{string-ref}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(string-length "Hello, world!") ; => 13
(string-append "Hello, " "world!") ; => "Hello, world!"
(string->list "Hello") ; => '(#\H #\e #\l #\l #\o)
(list->string '(#\H #\e #\l #\l #\o)) ; => "Hello"
(string-ref "Hello" 0) ; => #\H
\end{lstlisting}

  \paragraph{Operations on bools}

  \begin{itemize}
    \item logic operations: \iracket{and}, \iracket{or}, \iracket{not}, \iracket{xor}
    \item implication: \iracket{implies}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(and #t #f) ; => #f
(or #t #f) ; => #t
(not #t) ; => #f
(xor #t #f) ; => #t
(implies #t #f) ; => #f
\end{lstlisting}

  \subsection{Functions}

  \begin{itemize}
    \item anonymous functions: \iracket{(lambda (<arg1> <arg2> ...) <body>)}
    \item named functions: \iracket{(define (<name> <arg1> <arg2> ...) <body>)}
    \item old way: \iracket{(define <name> (lambda (<arg1> <arg2> ...) <body>))}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(lambda (x) (+ x 1)) ;
(define (add1 x) (+ x 1)) ;
\end{lstlisting}

  \subsubsection{Higher order functions}

  \begin{itemize}
    \item apply a function to each element of a list: \iracket{map}
    \item apply a filter: \iracket{filter}
    \item apply a function to each element of a list and flatten the result: \iracket{apply}
    \item fold a list: \iracket{foldl}, \iracket{foldr}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(map add1 '(1 2 3)) ; => '(2 3 4)
(filter even? '(1 2 3 4)) ; => '(2 4)
(apply append '((1 2) (3 4))) ; => '(1 2 3 4)
(foldl + 0 '(1 2 3)) ; => 6
(foldr + 0 '(1 2 3)) ; => 6
\end{lstlisting}


  \subsection{Variables}

  \begin{itemize}
    \item parallel binding: \iracket{let}
    \item serial binding: \iracket{let*}
    \item recursive binding: \iracket{letrec}
    \item recursive serial binding: \iracket{letrec*}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(let ((x 5) (y 2)) (list x y)) ; => '(5 2)
(let* ((x 1) (y (add1 x))) (list x y)) ; // '(1 2)
\end{lstlisting}

  \subsection{Mutation}

  \begin{itemize}
    \item all mutators end with \iracket{\!}
    \item \iracket{set\!} is used to mutate variables
    \item \iracket{vector-set\!} is used to mutate vectors
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(define x 5) ; => x = 5
(set! x 6) ; => x = 6
(define v (vector 2 2 3 4)) ; => v = '#(2 2 3 4)
(vector-set! v 0 1) ; => v = '#(1 2 3 4)
\end{lstlisting}

  \subsection{Collections}

  \subsubsection{Structs}

  \begin{itemize}
    \item definition: \iracket{(struct <struct-name> (<field> ...))}
    \item constructor: \iracket{(define <name> <struct-name> <field-value> ...)}
    \item getter: \iracket{<struct-name>-<field-name>}
    \item setter: \iracket{set-<struct-name>-<field-name>\!}
    \item predicate: \iracket{<struct-name>?}
    \item structs and fields are immutable by default
    \item use \iracket{#:mutable} keyword on struct or field to make it mutable
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(struct point (x y)) ; => point
(define p (point 1 2)) ; => p = (point 1 2)
(point-x p) ; => 1
(point? p) ; => #t

(struct mut-point (x y #:mutable)) ; => point
(define mp (mut-point 1 2)) ; => mp = (mut-point 1 2)
(set-mut-point-x! mp 5) ; => mp = (mut-point 5 2)
\end{lstlisting}

  \subsubsection{Pairs}

  \begin{itemize}
    \item definition: \iracket{(cons <first> <second>)}
    \item getter of first element: \iracket{car}
    \item getter of second element: \iracket{cdr}
    \item car and cdr can be composed: \iracket{cadddr}, \iracket{caaar}
    \item pairs are immutable
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(cons 1 2) ; => '(1 . 2)
(car '(1 . 2)) ; => 1
(cdr '(1 . 2)) ; => 2
(caar '((1 . 2) . 3)) ; => 1
(cadr '((1 . 2) . 3)) ; => 2
(cdar '((1 . 2) . 3)) ; => 2
(cddr '((1 . 2) . 3)) ; => 3
\end{lstlisting}

  \subsubsection{Lists}

  \begin{itemize}
    \item lists are composed of pairs
    \item manually defined via \iracket{quote}: \iracket{'(1 2 3)}
    \item empty list: \iracket{'()}
    \item list of length \iracket{n}: \iracket{(build-list <n> <procedure>)}
    \item list of length \iracket{n} with initial value \iracket{<init>}: \iracket{(make-list <n> <init>)}
    \item lists are made by pairs
          \begin{itemize} \item the \iracket{car} contains the first value
            \item the \iracket{cdr} contains the the rest of the list
            \item the last pair has \iracket{cdr} equal to \iracket{'()}
          \end{itemize}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
'(1 2 3) ; => '(1 2 3)
'(1 . (2 . (3 . ()))) ; => '(1 2 3)
\end{lstlisting}

  \paragraph{Operations on lists}

  \begin{itemize}
    \item list length: \iracket{length}
    \item add an element at the beginning: \iracket{cons}
    \item add an element at the end: \iracket{append}
    \item take the first element: \iracket{first}
    \item take the last element: \iracket{last}
    \item take the n-th element: \iracket{list-ref <list> <n>}
    \item take the n-th element after pos: \iracket{list-tail <list> <pos>}
    \item take the first n elements: \iracket{take <list> <n>}
    \item take the last n elements: \iracket{drop <list> <n>}
    \item count the occurrences of an element: \iracket{count <predicate> <list>}
    \item apply a filter: \iracket{filter <predicate>}
    \item apply a function to each element: \iracket{map <function>}
    \item get the reverse of a list: \iracket{reverse}
    \item get the elements after the first: \iracket{rest}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(length '(1 2 3)) ; => 3
(cons 1 '(2 3)) ; => '(1 2 3)
(append '(1 2) '(3 4)) ; => '(1 2 3 4)
(first '(1 2 3)) ; => 1
(last '(1 2 3)) ; => 3
(list-ref '(1 2 3) 1) ; => 2
(list-tail '(1 2 3) 1) ; => '(2 3)
(take '(1 2 3) 2) ; => '(1 2)
(drop '(1 2 3) 1) ; => '(2 3)
(count even? '(1 2 3 4)) ; => 2
(filter even? '(1 2 3 4)) ; => '(2 4)
(map add1 '(1 2 3)) ; => '(2 3 4)
(reverse '(1 2 3)) ; => '(3 2 1)
(rest '(1 2 3)) ; => '(2 3)
\end{lstlisting}

  \paragraph{Lists folding}

  \begin{itemize}
    \item lists can be folded from the left with \iracket{foldl}
    \item lists can be folded from the right with \iracket{foldr}
    \item the accumulator is the first argument of the function
    \item the list is the second argument of the function
    \item the function is applied to the accumulator and the first element of the list
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(foldl + 0 '(1 2 3 4)) ; => 10
(foldr * 1 '(1 2 3 4)) ; => 24
  \end{lstlisting}

  \subsubsection{Vectors}

  \begin{itemize}
    \item definition: \iracket{#(<element> ...)}
    \item getter: \iracket{vector-ref}
    \item vector are immutable, fixed size and zero-indexed
  \end{itemize}

  \begin{lstlisting}[language=Racket]
#(1 2 3) ; => '#(1 2 3)
(vector-ref '#(1 2 3) 0) ; => 1
  \end{lstlisting}

  \subsubsection{Sets}

  \begin{itemize}
    \item definition: \iracket{(set <element> ...)}
    \item convert a list to a set: \iracket{list->set}
    \item add an element: \iracket{set-add}
    \item remove an element: \iracket{set-remove}
    \item test if an element is in the set: \iracket{set-member?}
    \item sets don't allow duplicates, are unordered and mutable
    \item methods return a new set instead of changing the original one
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(set 1 2 3) ; => '#(1 2 3)
(list->set '(1 2 3)) ; => '#(1 2 3)
(set-add (set 1 2 3) 4) ; => '#(1 2 3 4)
(set-remove (set 1 2 3) 2) ; => '#(1 3)
(set-member? (set 1 2 3) 2) ; => #t
  \end{lstlisting}

  \subsubsection{Hash}

  \begin{itemize}
    \item definition: \iracket{(hash <key> <value> ...)}
    \item add a key-value pair: \iracket{hash-set}
    \item remove a key-value pair: \iracket{hash-remove}
    \item get a value from a key: \iracket{hash-ref}
    \item test if a key is in the hash: \iracket{hash-has-key?}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(hash 1 2 3 4) ; => '#hash((1 . 2) (3 . 4))
(hash-set (hash 1 2 3 4) 5 6) ; => '#hash((1 . 2) (3 . 4) (5 . 6))
(hash-remove (hash 1 2 3 4) 3) ; => '#hash((1 . 2) (4 . 4))
(hash-ref (hash 1 2 3 4) 1) ; => 2
(hash-has-key? (hash 1 2 3 4) 1) ; => #t
  \end{lstlisting}

  \subsection{Control flow}

  \subsubsection{Conditionals}

  \paragraph{if}

  \begin{itemize}
    \item if: \iracket{(if <predicate> <then> <else>)}
    \item when: \iracket{(when <predicate> <then>)}
    \item unless: \iracket{(unless <predicate> <else>)}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(if #t 1 2) ; => 1
(when #t 1) ; => 1
(when #f 1) ; => #<void>
(unless #t 1) ; => #<void>
(unless #f 1) ; => 1
  \end{lstlisting}

  \paragraph{cond - case}

  \begin{itemize}
    \item cond: \iracket{(cond [<predicate> <then>] ... [<else> <else-then>])}
    \item case: \iracket{(case <value> [<case-clause> <then>] ... [<else> <else-then>])}
    \item the \iracket{else} clause is optional
    \item in cond, the value is evaluated against each predicate
    \item in case, the value is evaluated against each clause whose quote is \iracket{eqv?}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(case (+ 7 5)
  [(1 2 3) 'small]
  [(10 11 12) 'big]
  [else 'neither]) ; => 'big
(let ((x 0))
  (cond ((positive? x) 'positive)
    ((negative? x) 'negative)
    (else 'zero))) ; => 'zero
  \end{lstlisting}

  \paragraph{pattern matching}

  \begin{itemize}
    \item match: \iracket{(match <value> [<pattern> <then>] ... [_ <else-then>])}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
    (define (fizzbuzz? n)
    (match (list (remainder n 3) (remainder n 5))
      [(list 0 0) 'fizzbuzz]
      [(list 0 _) 'fizz]
      [(list _ 0) 'buzz]
      [_          #f]))

  (fizzbuzz? 15) ; => 'fizzbuzz
  (fizzbuzz? 37) ; => #f
  \end{lstlisting}

  \subsubsection{Loops}

  \paragraph{when}

  \begin{itemize}
    \item when: \iracket{(when <predicate> <then>)}
    \item also available as named let
  \end{itemize}

  \begin{lstlisting}[language=Racket]
;; named let
(let label ((x 0)) ; initialize x as 0
(when (< x 10) ; iterate while x < 10
  (display x) ; print x
  (newline)
  (label (+ x 1)))) ; increment x, go back to label

(define (loop i)
  (when (< i 10)
    (printf "i=~a\n" i)
    (loop (add1 i))))
(loop 5) ; => i=5, i=6, i=7, i=8, i=9
  \end{lstlisting}

  \paragraph{for}

  \begin{itemize}
    \item for in a range: \iracket{(for ([<var> <start> <end>]) <body>)}
    \item for over lists: \iracket{(for ([<var> <list>]) <body>)}
    \item for is available for other collections
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(for ([i 10])
  (printf "i=~a\n" i)) ; => i=0, i=1, ...
(for ([i (in-range 5 10)])
  (printf "i=~a\n" i)) ; => i=5, i=6, ...

(for ([i (in-list '(l i s t))])
  (displayln i))

(for ([i (in-vector #(v e c t o r))])
  (displayln i))

(for ([i (in-string "string")])
  (displayln i))

(for ([i (in-set (set 'x 'y 'z))])
  (displayln i))

(for ([(k v) (in-hash (hash 'a 1 'b 2 'c 3))])
  (printf "key:~a value:~a\n" k v))
  \end{lstlisting}

  \subsection{Macros and syntax rules}

  \begin{itemize}
    \item macros are defined via \iracket{define-syntax(<name> <expansion>)}
    \item syntax rules are defined via \iracket{syntax-rules(<pattern> <expansion>)}
    \item macros are expanded at compile time
    \item syntax rule are pairs \iracket{(<pattern> <expansion>)}
    \item the \iracket{...} operator indicates repetitions of patterns
    \item the \iracket{_} operator is used to match any syntax object
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(define-syntax while
  (syntax-rules ()          ; no other keyword is needed
    ((_ condition body ...) ; pattern P
      (let loop ()           ; expansion of P
        (when condition
          ((begin body ...
                  (loop))))))))
  \end{lstlisting}

  \subsection{Continuations}

  \begin{itemize}
    \item two ways to call a continuation:
          \begin{itemize}
            \item \iracket{call-with-current-continuation <procedure>}
            \item \iracket{call/cc <procedure>}
          \end{itemize}
    \item saving the continuation: \iracket{save\! <continuation>}
  \end{itemize}

  \subsection{Exceptions}

  \begin{itemize}
    \item exceptions are implemented via continuations
    \item raise an exception: \iracket{raise}
    \item catch an exception: \iracket{with-handlers}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(with-handlers ([exn:fail? (lambda (e) (printf "error: ~a\n" e))])
  (raise (exn:fail "error message"))) ; => error: error message
  \end{lstlisting}

\end{multicols*}

\clearpage

\section{Erlang}

\clearpage

\section{Haskell}


\end{document}