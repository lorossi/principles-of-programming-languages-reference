\documentclass[a4paper,landscape,10pt]{article}

\usepackage{settings}

% TODO: when everything has been written, space correctly the content by breaking the columns via the (custom)\breakcolumn command

\begin{document}

\section{Racket}
\begin{multicols*}{2}
  \subsection{Comments}

  \begin{itemize}
    \item single line comment: \iracket{;}
    \item multi-line comment: \iracket{\#| ... |\#}
    \item multi-line comments can be nested
  \end{itemize}

  \begin{lstlisting}[language=Racket]
; single line comment
#|
  multi-line-comment
	can span
	multiple lines
  end of comment
|#
\end{lstlisting}

  \subsection{Data types}

  \begin{itemize}
    \item typing is dynamic
    \item types:
          \begin{itemize}
            \item boolean: \iracket{#t, #f}
            \item integer: \iracket{9125}
            \item binary: \iracket{#b10001110100101}
            \item octal: \iracket{#o21645}
            \item hexadecimal: \iracket{#x23a5}
            \item real: \iracket{91.25}
            \item rational: \iracket{91/25}
            \item complex: \iracket{91+25i}
            \item character: \lstinline[language=Racket]!#\A, #\$\lambda$, #\u30BB!
            \item null element: \iracket{'(), null}
            \item string: \iracket{"Hello, world!"}
          \end{itemize}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(define x 5) ; => x = 5
(define y "Hello, world!") ; => y = "Hello, world!"
(define z #t) ; => z = #t
(define w #\A) ; => w = #\A
null ; => '()
\end{lstlisting}

  \subsection{Variables}

  \begin{itemize}
    \item variables are immutable
    \item parallel binding: \iracket{let}
    \item serial binding: \iracket{let*}
    \item recursive binding: \iracket{letrec}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(let ((x 5) (y 2)) (list x y)) ; => '(5 2)
(let* ((x 1) (y (add1 x))) (list x y)) ; // '(1 2)
\end{lstlisting}

  \subsubsection{Datum evaluation}

  \begin{itemize}
    \item \iracket{quote <datum>} or \iracket{'<datum>} leaves the datum as-is
    \item \iracket{unquote <datum>} or \iracket{,<datum>} is the opposite of \iracket{quote}
    \item \iracket{quasiquote <datum>} or \iracket{,@<datum>} allows to apply the unquote where needed
  \end{itemize}

  \begin{lstlisting}[language=Racket]
'(1 2 3); => (1 2 3)
(1 ,(+ 1 1) 3) ; => '(1 2 3)
\end{lstlisting}

  \subsubsection{Equivalence}

  \begin{itemize}
    \item numbers equivalence: \iracket{=}
    \item objects or numbers equivalence: \iracket{eq?}
    \item objects equivalence: \iracket{eqv?}
    \item objects equivalence: \iracket{equal?}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(= 1 1) ; => #t
(eq? 1 0) ; => #f
(eqv? 'yes 'yes) ; => #t
(equal? 'yes 'no) ; => #f
\end{lstlisting}

  \subsubsection{Basic operations}

  \begin{itemize}
    \item all operations are in prefix notation \iracket{<operator> <operand> ...}
  \end{itemize}

  \breakcolumn

  \paragraph{Operations on numbers}

  \begin{itemize}
    \item arithmetic operations: \iracket{+}, \iracket{-}, \iracket{*}, \iracket{/}
    \item exponentiation: \iracket{expt}
    \item exponentiation by \(e\): \iracket{exp}
    \item logarithm: \iracket{log}
    \item quotient: \iracket{quotient}
    \item remainder: \iracket{remainder}
    \item largest and smallest of two numbers: \iracket{max}, \iracket{min}
    \item add \(1\): \iracket{add1}
    \item subtract \(1\): \iracket{sub1}
    \item greatest common divisor: \iracket{gcd}
    \item least common multiple: \iracket{lcm}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(+ 1 2 3) ; => 6
(- 1 2 3) ; => -4
(expt 2 3) ; => 8
(exp 2) ; => e ** 2 = 7.38905609893065
(log 10) ; => 2.302585092994046
(quotient 5 2) ; => 2
(remainder 5 2) ; => 1
(max 1 2) ; => 2
(min 1 2) ; => 1
(add1 5) ; => 6
(sub1 5) ; => 4
(gcd 12 18) ; => 6
(lcm 12 18) ; => 36
\end{lstlisting}

  \paragraph{Operations on strings}

  \begin{itemize}
    \item string length: \iracket{string-length}
    \item string append: \iracket{string-append}
    \item string to list: \iracket{string->list}
    \item list to string: \iracket{list->string}
    \item get n-th character: \iracket{string-ref}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(string-length "Hello, world!") ; => 13
(string-append "Hello, " "world!") ; => "Hello, world!"
(string->list "Hello") ; => '(#\H #\e #\l #\l #\o)
(list->string '(#\H #\e #\l #\l #\o)) ; => "Hello"
(string-ref "Hello" 0) ; => #\H
\end{lstlisting}

  \paragraph{Operations on bools}

  \begin{itemize}
    \item logic operations: \iracket{and}, \iracket{or}, \iracket{not}, \iracket{xor}
    \item implication: \iracket{implies}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(and #t #f) ; => #f
(or #t #f) ; => #t
(not #t) ; => #f
(xor #t #f) ; => #t
(implies #t #f) ; => #f
\end{lstlisting}

  \subsubsection{Types conversion}

  \begin{itemize}
    \item inexact and exact: \iracket{inexact->exact}, \iracket{exact->inexact}
    \item integer and float: \iracket{integer->float}, \iracket{float->integer}
    \item integer and rational: \iracket{integer->rational}, \iracket{rational->integer}
    \item list and vector: \iracket{list->vector}, \iracket{vector->list}
    \item vector and string: \iracket{vector->string}, \iracket{string->vector}
  \end{itemize}

  \subsection{Predicates}

  \begin{itemize}
    \item all predicates end with \iracket{?}
    \item checks if a number is even: \iracket{even?}
    \item checks if a number is odd: \iracket{odd?}
    \item check if a datum is true: \iracket{true?}
    \item check if a datum is false: \iracket{false?}
    \item check if a number is positive: \iracket{positive?}
    \item check if a number is negative: \iracket{negative?}
    \item check if a number is zero: \iracket{zero?}
    \item check if an object is immutable \iracket{immutable?}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(even? 2) ; => #t
(odd? 2) ; => #f
(true? #t) ; => #t
(false? #t) ; => #f
(positive? 1) ; => #t
(negative? 1) ; => #f
(zero? 1) ; => #f
\end{lstlisting}

  \breakcolumn

  \subsection{Functions}

  \begin{itemize}
    \item anonymous functions: \iracket{lambda (<arg1> <arg2> ...) <body>}
    \item named functions: \iracket{define (<name> <arg1> <arg2> ...) <body>}
    \item old way: \iracket{define <name> (lambda (<arg1> <arg2> ...) <body>)}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(lambda (x) (+ x 1)) ;
(define (add1 x) (+ x 1)) ;
\end{lstlisting}

  \subsubsection{Higher order functions}

  \begin{itemize}
    \item apply a function to each element of a list: \iracket{map <function> <list>}
    \item apply a filter: \iracket{filter <predicate> <list>}
    \item apply a function to each element of a list and flatten the result: \iracket{apply <function> <list>}
    \item fold a list: \iracket{foldl <function> <accumulator> <list>}
    \item fold a list: \iracket{foldr <function> <accumulator> <list>}
    \item \iracket{foldl} has space complexity \(O(1)\)
    \item \iracket{foldr} has space complexity \(O(n)\)
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(map add1 '(1 2 3)) ; => '(2 3 4)
(filter even? '(1 2 3 4)) ; => '(2 4)
(apply append '((1 2) (3 4))) ; => '(1 2 3 4)
(foldl + 0 '(1 2 3)) ; => 6
(foldr + 0 '(1 2 3)) ; => 6
\end{lstlisting}

  \subsection{Mutation}

  \begin{itemize}
    \item all mutators end with \iracket{\!}
    \item \iracket{set\!} is used to mutate variables
    \item \iracket{vector-set\!} is used to mutate vectors
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(define x 5) ; => x = 5
(set! x 6) ; => x = 6
(define v (vector 2 2 3 4)) ; => v = '#(2 2 3 4)
(vector-set! v 0 1) ; => v = '#(1 2 3 4)
\end{lstlisting}

  \breakcolumn

  \subsection{Collections}

  \subsubsection{Structs}

  \begin{itemize}
    \item definition: \iracket{struct <struct-name> (<field> ...)}
    \item constructor: \iracket{define <name> <struct-name> <field-value> ...}
    \item getter: \iracket{<struct-name>-<field-name>}
    \item setter: \iracket{set-<struct-name>-<field-name>\!}
    \item predicate: \iracket{<struct-name>?}
    \item structs and fields are immutable by default
    \item use \iracket{#:mutable} keyword on struct or field to make it mutable
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(struct point (x y)) ; => point
(define p (point 1 2)) ; => p = (point 1 2)
(point-x p) ; => 1
(point? p) ; => #t

(struct mut-point (x y #:mutable)) ; => point
(define mp (mut-point 1 2)) ; => mp = (mut-point 1 2)
(set-mut-point-x! mp 5) ; => mp = (mut-point 5 2)
\end{lstlisting}

  \subsubsection{Pairs}

  \begin{itemize}
    \item definition: \iracket{cons <first> <second>}
    \item getter of first element: \iracket{car}
    \item getter of second element: \iracket{cdr}
    \item car and cdr can be composed: \iracket{cadddr}, \iracket{caaar}, \ldots
    \item pairs are immutable
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(cons 1 2) ; => '(1 . 2)
(car '(1 . 2)) ; => 1
(cdr '(1 . 2)) ; => 2
(caar '((1 . 2) . 3)) ; => 1
(cadr '((1 . 2) . 3)) ; => 2
(cdar '((1 . 2) . 3)) ; => 2
(cddr '((1 . 2) . 3)) ; => 3
\end{lstlisting}

  \breakcolumn

  \subsubsection{Lists}

  \begin{itemize}
    \item lists are composed of pairs
    \item manually defined via \iracket{quote}: \iracket{'(1 2 3)}
    \item empty list: \iracket{'()}
    \item list of length \iracket{n}: \iracket{build-list <n> <procedure>}
    \item list of length \iracket{n} with initial value \iracket{<init>}: \iracket{make-list <n> <init>}
    \item lists are made by pairs
          \begin{itemize} \item the \iracket{car} contains the first value
            \item the \iracket{cdr} contains the the rest of the list
            \item the last pair has \iracket{cdr} equal to \iracket{'()}
          \end{itemize}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
'(1 2 3) ; => '(1 2 3)
'(1 . (2 . (3 . ()))) ; => '(1 2 3)
\end{lstlisting}

  \paragraph{Operations on lists}

  \begin{itemize}
    \item list length: \iracket{length}
    \item add an element at the beginning: \iracket{cons}
    \item add an element at the end: \iracket{append}
    \item get the elements after the first: \iracket{rest <list>}
    \item get the first element: \iracket{first}
    \item get the last element: \iracket{last}
    \item get the n-th element: \iracket{list-ref <list> <n>}
    \item get the elements after the n-th: \iracket{list-tail <list> <pos>}
    \item get the first n elements: \iracket{take <list> <n>}
    \item get the last n elements: \iracket{drop <list> <n>}
    \item count the occurrences of an element: \iracket{count <predicate> <list>}
    \item apply a filter: \iracket{filter <predicate> <list>}
    \item apply a function to each element: \iracket{map <function> <list>}
    \item get the reverse of a list: \iracket{reverse <list>}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(length '(1 2 3)) ; => 3
(cons 1 '(2 3)) ; => '(1 2 3)
(append '(1 2) '(3 4)) ; => '(1 2 3 4)
(first '(1 2 3)) ; => 1
(last '(1 2 3)) ; => 3
(list-ref '(1 2 3) 1) ; => 2
(list-tail '(1 2 3) 1) ; => '(2 3)
(take '(1 2 3) 2) ; => '(1 2)
(drop '(1 2 3) 1) ; => '(2 3)
(count even? '(1 2 3 4)) ; => 2
(filter even? '(1 2 3 4)) ; => '(2 4)
(map add1 '(1 2 3)) ; => '(2 3 4)
(reverse '(1 2 3)) ; => '(3 2 1)
(rest '(1 2 3)) ; => '(2 3)
\end{lstlisting}

  \paragraph{Lists folding}

  \begin{itemize}
    \item lists can be folded from the left with \iracket{foldl}
    \item lists can be folded from the right with \iracket{foldr}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(foldl + 0 '(1 2 3 4)) ; => 10
(foldr * 1 '(1 2 3 4)) ; => 24
  \end{lstlisting}

  \subsubsection{Vectors}

  \begin{itemize}
    \item definition: \iracket{#(<element> ...)}
    \item getter: \iracket{vector-ref}
    \item vector are immutable, fixed size and zero-indexed
  \end{itemize}

  \begin{lstlisting}[language=Racket]
#(1 2 3) ; => '#(1 2 3)
(vector-ref '#(1 2 3) 0) ; => 1
  \end{lstlisting}

  \subsubsection{Sets}

  \begin{itemize}
    \item definition: \iracket{set <element> ...}
    \item convert a list to a set: \iracket{list->set}
    \item add an element: \iracket{set-add}
    \item remove an element: \iracket{set-remove}
    \item test if an element is in the set: \iracket{set-member?}
    \item sets don't allow duplicates, are unordered and mutable
    \item methods return a new set instead of changing the original one
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(set 1 2 3) ; => '#(1 2 3)
(list->set '(1 2 3)) ; => '#(1 2 3)
(set-add (set 1 2 3) 4) ; => '#(1 2 3 4)
(set-remove (set 1 2 3) 2) ; => '#(1 3)
(set-member? (set 1 2 3) 2) ; => #t
  \end{lstlisting}

  \breakcolumn

  \subsubsection{Hash}

  \begin{itemize}
    \item definition: \iracket{hash <key> <value> ...}
    \item add a key-value pair: \iracket{hash-set}
    \item remove a key-value pair: \iracket{hash-remove}
    \item get a value from a key: \iracket{hash-ref}
    \item test if a key is in the hash: \iracket{hash-has-key?}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(hash 1 2 3 4) ; => '#hash((1 . 2) (3 . 4))
(hash-set (hash 1 2 3 4) 5 6) ; => '#hash((1 . 2) (3 . 4) (5 . 6))
(hash-remove (hash 1 2 3 4) 3) ; => '#hash((1 . 2) (4 . 4))
(hash-ref (hash 1 2 3 4) 1) ; => 2
(hash-has-key? (hash 1 2 3 4) 1) ; => #t
  \end{lstlisting}

  \subsection{Control flow}

  \subsubsection{Conditionals}

  \paragraph{if}

  \begin{itemize}
    \item if: \iracket{if <predicate> <then> <else>}
    \item when: \iracket{when <predicate> <then>}
    \item unless: \iracket{unless <predicate> <else>}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(if #t 1 2) ; => 1
(when #t 1) ; => 1
(when #f 1) ; => #<void>
(unless #t 1) ; => #<void>
(unless #f 1) ; => 1
  \end{lstlisting}

  \breakcolumn

  \paragraph{cond - case}

  \begin{itemize}
    \item cond: \iracket{cond [<predicate> <then>] ... [<else> <else-then>]}
    \item case: \iracket{case <value> [<case-clause> <then>] ... [<else> <else-then>]}
    \item the \iracket{else} clause is optional
    \item in cond, the value is evaluated against each predicate
    \item in case, the value is evaluated against each clause whose quote is \iracket{eqv?}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(case (+ 7 5)
  [(1 2 3) 'small]
  [(10 11 12) 'big]
  [else 'neither]) ; => 'big
(let ((x 0))
  (cond ((positive? x) 'positive)
    ((negative? x) 'negative)
    (else 'zero))) ; => 'zero
  \end{lstlisting}

  \paragraph{pattern matching}

  \begin{itemize}
    \item match: \iracket{match <value> [<pattern> <then>] ... [_ <else-then>]}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
    (define (fizzbuzz? n)
    (match (list (remainder n 3) (remainder n 5))
      [(list 0 0) 'fizzbuzz]
      [(list 0 _) 'fizz]
      [(list _ 0) 'buzz]
      [_          #f]))

  (fizzbuzz? 15) ; => 'fizzbuzz
  (fizzbuzz? 37) ; => #f
  \end{lstlisting}

  \breakcolumn

  \subsubsection{Loops}

  \paragraph{when}

  \begin{itemize}
    \item when: \iracket{when <predicate> <then>}
    \item also available as named let
  \end{itemize}

  \begin{lstlisting}[language=Racket]
;; named let
(let label ((x 0)) ; initialize x as 0
(when (< x 10) ; iterate while x < 10
  (display x) ; print x
  (newline)
  (label (+ x 1)))) ; increment x, go back to label

(define (loop i)
  (when (< i 10)
    (printf "i=~a\n" i)
    (loop (add1 i))))
(loop 5) ; => i=5, i=6, i=7, i=8, i=9
  \end{lstlisting}

  \paragraph{for}

  \begin{itemize}
    \item for in a range: \iracket{for ([<var> <start> <end>]) <body>}
    \item for over lists: \iracket{for ([<var> <list>]) <body>}
    \item for is available for other collections
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(for ([i 10])
  (printf "i=~a\n" i)) ; => i=0, i=1, ...
(for ([i (in-range 5 10)])
  (printf "i=~a\n" i)) ; => i=5, i=6, ...

(for ([i (in-list '(l i s t))])
  (displayln i))

(for ([i (in-vector #(v e c t o r))])
  (displayln i))

(for ([i (in-string "string")])
  (displayln i))

(for ([i (in-set (set 'x 'y 'z))])
  (displayln i))

(for ([(k v) (in-hash (hash 'a 1 'b 2 'c 3))])
  (printf "key:~a value:~a\n" k v))
  \end{lstlisting}

  \subsection{Macros and syntax rules}

  \begin{itemize}
    \item definition: \iracket{define-syntax((<literals>) [(<syntax-rule> ...), ...])}
    \item syntax rules are defined via \iracket{syntax-rules(<pattern> <expansion>)}
    \item macros are expanded at compile time
    \item the \iracket{...} operator indicates repetitions of patterns
    \item the \iracket{_} operator is used to match any syntax object
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(define-syntax while
  (syntax-rules ()          ; no reserved keywords
    ((_ condition body ...) ; pattern P
      (let loop ()          ; expansion of P
        (when condition
          ((begin body ...
                  (loop))))))))
  \end{lstlisting}

  \subsection{Continuations}

  \begin{itemize}
    \item two ways to call a continuation:
          \begin{itemize}
            \item \iracket{call-with-current-continuation <procedure>}
            \item \iracket{call/cc <procedure>}
          \end{itemize}
    \item saving the continuation: \iracket{save\! <continuation>}
  \end{itemize}

  \subsection{Exceptions}

  \begin{itemize}
    \item exceptions are implemented via continuations
    \item raise an exception: \iracket{raise}
    \item catch an exception: \iracket{with-handlers}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(with-handlers ([exn:fail? (lambda (e) (printf "error: ~a\n" e))])
  (raise (exn:fail "error message"))) ; => error: error message
  \end{lstlisting}

\end{multicols*}

\clearpage

\section{Haskell}

\begin{multicols*}{2}

  \subsection{Comments}

  \begin{itemize}
    \item single line comment: \ihaskell{--}
    \item multi-line comment: \ihaskell{\{- ... -\}}

  \end{itemize}

  \begin{lstlisting}[language=Haskell]
-- single line comment
{- multi-line comment
  can span
  multiple lines
  end of comment -}
\end{lstlisting}

  \subsection{Data types}

  \begin{itemize}
    \item data type is inferred automatically by the compiler
    \item data type can be specified explicitly via type annotations \ihaskell{::}
    \item types:
          \begin{itemize}
            \item boolean: \ihaskell{True, False}
            \item integer: \ihaskell{1, 2, 3}
            \item float, double: \ihaskell{1.0, 2.0, 3.0}
            \item complex: \ihaskell{1 :+ 2, 2 :+ 3, 3 :+ 4}
            \item character: \ihaskell{'a', 'b', 'c'}
            \item string: \ihaskell{["a", "b", "c"]} or \ihaskell{"abc"}
            \item lists: \ihaskell{[1, 2, 3]}
            \item tuples: \ihaskell{(1, 2, 3)}
          \end{itemize}
  \end{itemize}

  \subsubsection{User defined types}

  \begin{itemize}
    \item sum types: \ihaskell{data <type> = <constructor1> | <constructor2> | ...}
    \item product type: \ihaskell{data <type> = <constructor> <field1> <field2> ...}
  \end{itemize}

  \begin{lstlisting}[language=Haskell]
data Bool = True | False -- sum type
data Point = Point Float Float -- product type
\end{lstlisting}

  \subsubsection{Recursive types}

  \begin{itemize}
    \item syntax: \ihaskell{data <type> = <constructor> <field1> <field2> ... <type>}
  \end{itemize}

  \begin{lstlisting}[language=Haskell]
data Tree a = Empty | Node a (Tree a) (Tree a)
\end{lstlisting}

  \subsubsection{Type Synonyms}

  \begin{itemize}
    \item syntax: \ihaskell{type <name> = <type>}
  \end{itemize}

  \begin{lstlisting}[language=Haskell]
type Point = [(Float, Float)]
\end{lstlisting}

  \subsection{Variables}

  \begin{itemize}
    \item variables are immutable
    \item recursive binding: \ihaskell{let}
    \item declaration with function body: \ihaskell{where}
  \end{itemize}

  \begin{lstlisting}[language=Haskell]
let x = 5 in x + 1 ; => 6
let x = 5
  y = 2
in x + y ; => 7
f x = x + 1
where x = 5 ; => 6
\end{lstlisting}

  \subsubsection{Equivalence}

  \begin{itemize}
    \item equivalence between objects, numbers, strings and characters: \ihaskell{==}
  \end{itemize}

  \subsubsection{Basic operations}

  \begin{itemize}
    \item prefix operators can be converted into infix notation via backticks \ihaskell{`<operator>`}
    \item infix operators can be converted into prefix notation via parentheses \ihaskell{(<operator>)}
    \item symbol \ihaskell{\$} is used to avoid parentheses by applying the function to the right
  \end{itemize}

  \breakcolumn

  \paragraph{Operations on numbers}

  \begin{itemize}
    \item arithmetic operations: \ihaskell{+}, \ihaskell{-}, \ihaskell{*}, \ihaskell{/}
    \item exponentiation: \ihaskell{**}
    \item exponentiation by e: \ihaskell{exp}
    \item logarithm: \ihaskell{log}
    \item quotient: \ihaskell{quot}
    \item remainder: \ihaskell{rem}
    \item largest and smallest of two numbers: \ihaskell{max}, \ihaskell{min}
    \item add \(1\): \ihaskell{succ}
    \item subtract \(1\): \ihaskell{pred}
    \item greatest common divisor: \ihaskell{gcd}
    \item least common multiple: \ihaskell{lcm}
  \end{itemize}

  \begin{lstlisting}[language=Haskell]
3 + 2 ; => 5
3 - 2 ; => 1
3 * 2 ; => 6
3 / 2 ; => 1.5
3 ** 2 ; => 9.0
exp 2 ; => 7.38905609893065
log 10 ; => 2.302585092994046
quot 5 2 ; => 2
rem 5 2 ; => 1
max 1 2 ; => 2
min 1 2 ; => 1
succ 5 ; => 6
pred 5 ; => 4
gcd 12 18 ; => 6
lcm 12 18 ; => 36
\end{lstlisting}

  \paragraph{Operations on strings}

  \begin{itemize}
    \item string length: \ihaskell{length}
    \item string append: \ihaskell{++}
    \item string to list: \ihaskell{words}
    \item list to string: \ihaskell{unwords}
  \end{itemize}

  \begin{lstlisting}[language=Haskell]
length "Hello, world!" ; => 13
"Hello, " ++ "world!" ; => "Hello, world!"
words "Hello world!" ; => ["Hello", "world!"]
unwords ["Hello", "world!"] ; => "Hello world!"
\end{lstlisting}

  \breakcolumn

  \paragraph{Operations on bools}

  \begin{itemize}
    \item logic operations: \ihaskell{&&}, \ihaskell{||}, \ihaskell{not}, \ihaskell{xor}
    \item implication: \ihaskell{implies}
  \end{itemize}

  \begin{lstlisting}[language=Haskell]
True && False ; => False
True || False ; => True
not True ; => False
xor True False ; => True
implies True False ; => False
\end{lstlisting}

  \subsubsection{Types conversion}

  \begin{itemize}
    \item list to string: \ihaskell{show}
    \item string to list: \ihaskell{read}
  \end{itemize}

  \subsection{Functions}

  \begin{itemize}
    \item lambda functions: \ihaskell{\\<name> <arg1> <arg2> ... -> <body>}
    \item functions are defined as sequences of equations
          \begin{itemize}
            \item arguments are matched with the right parts of equations, top to bottom
            \item if the match succeeds, the function body is called
          \end{itemize}
  \end{itemize}

  \begin{lstlisting}[language=Haskell]
\x y -> x + y ; => \x y -> x + y

length :: [a] -> Integer
length [] = 0
length (x:xs) = 1 + length xs
1 == 1 ; => True
"abc" == "abc" ; => True
\end{lstlisting}

  \subsection{Collections}

  \subsubsection{Fields}

  \begin{itemize}
    \item fields can be accessed either by label or by position
  \end{itemize}

  \subsubsection{Lists}

  \begin{itemize}
    \item lists are composed of pairs
    \item manual definition: \ihaskell{[1, 2, 3]}
    \item empty list: \ihaskell{[]}
  \end{itemize}

  \paragraph{Operations on lists}

  \begin{itemize}

    \item list length: \ihaskell{length <list>}
    \item get the reverse of a list: \ihaskell{reverse}
    \item concatenate two lists: \ihaskell{<list1> ++ <list2>}
    \item add an element: \ihaskell{<element> : <list>}
    \item get the first element: \ihaskell{head <list>}
    \item get the last element: \ihaskell{last <list>}
    \item get the n-th element: \ihaskell{<list> !! <position>}
    \item get the first n elements: \ihaskell{take <list> <n>}
    \item delete the first \ihaskell{n} elements: \ihaskell{drop <n> <list>}
    \item get all the elements after the first: \ihaskell{tail}
    \item split a list in two: \ihaskell{splitAt <position> <list>}
    \item apply a filter: \ihaskell{filter <predicate? <list>}
    \item apply a function to each element: \ihaskell{map <function> <list>}
    \item sum a list: \ihaskell{sum <list>}
    \item product of a list: \ihaskell{product <list>}
    \item check if a list is empty: \ihaskell{null <list>}
    \item check if an element is in a list: \ihaskell{elem <element> <list>}
    \item check if all elements of a list satisfy a predicate: \ihaskell{all <predicate> <list>}
    \item check if at least one element of a list satisfies a predicate: \ihaskell{any <predicate> <list>}
    \item zip two lists: \ihaskell{zip <list1> <list2>}
  \end{itemize}

  \begin{lstlisting}[language=Haskell]
length [1, 2, 3] ; => 3
reverse [1, 2, 3] ; => [3, 2, 1]
[1, 2, 3] ++ [4, 5, 6] ; => [1, 2, 3, 4, 5, 6]
1 : [2, 3] ; => [1, 2, 3]
head [1, 2, 3] ; => 1
last [1, 2, 3] ; => 3
[1, 2, 3] !! 1 ; => 2
take 2 [1, 2, 3] ; => [1, 2]
drop 2 [1, 2, 3] ; => [3]
tail [1, 2, 3] ; => [2, 3]
splitAt 1 [1, 2, 3] ; => ([1], [2, 3])
filter even [1, 2, 3, 4] ; => [2, 4]
map (+1) [1, 2, 3] ; => [2, 3, 4]
sum [1, 2, 3] ; => 6
product [1, 2, 3] ; => 6
null [] ; => True
elem 1 [1, 2, 3] ; => True
all even [2, 4, 6] ; => True
any even [1, 2, 3] ; => True
zip [1, 2, 3] [4, 5, 6] ; => [(1, 4), (2, 5), (3, 6)]
\end{lstlisting}

  \paragraph{Range notation}

  \begin{itemize}
    \item finite list: \ihaskell{[<start>..<end>]}
    \item finite list with step: \ihaskell{[<start>,<step>..<end>]}
    \item infinite list: \ihaskell{[<start>..]}
    \item infinite list with step: \ihaskell{[<start>,<step>..]}
    \item infinite list with one element repeated: \ihaskell{[<element>,<element>..]}
  \end{itemize}

  To explicitly evaluate a finite list use the \ihaskell{init} function.

  \begin{lstlisting}[language=Haskell]
-- all the following instructions are lazily evaluated
[1..10] ; => [1,2,3,4,5,6,7,8,9,10]
[1,3..10] ; => [1,3,5,7,9]
[1..] ; => [1,2,3,4,5,6,7,8,9,10,...]
[1,3..] ; => [1,3,5,7,9,...]
[1,1..] ; => [1,1,1,1,1,1,1,1,1,1,...]
\end{lstlisting}

  \paragraph{List Comprehension}

  \begin{itemize}
    \item list comprehension returns a list of elements created by evaluation of the generators
    \item syntax: \ihaskell{[<expression> | <generator>, <generator>, ...]}
  \end{itemize}

  \begin{lstlisting}[language=Haskell]
[x | x <- [1..10], even x] ; => [2,4,6,8,10]
[x * y | x <- [2,5,10], y <- [8,10,11]] ; => [16,20,22,40,50,55,80,100,110]
\end{lstlisting}

  \subsection{Control flow}

  \subsubsection{Pattern matching}

  \begin{itemize}
    \item the matching process is done top to bottom, left to right
    \item patterns may have boolean guards
    \item character \ihaskell{_} matches everything \textit{(don't care)}
  \end{itemize}

  \begin{lstlisting}[language=Haskell]
sign x | x > 0 = 1
| x < 0 = -1
| otherwise = 0

take 0 _ = []
take _ [] = []
take n (x:xs) = x : take (n - 1) xs
\end{lstlisting}

  \breakcolumn

  \subsubsection{Case}

  \begin{itemize}
    \item syntax: \ihaskell{case <value> of <pattern> -> <then> ...}
    \item the \ihaskell{_} pattern matches everything
  \end{itemize}

  \begin{lstlisting}[language=Haskell]
case x of
  0 -> "zero"
  1 -> "one"
  _ -> "other"
\end{lstlisting}

  \subsubsection{Conditionals}

  \begin{itemize}
    \item if: \ihaskell{if <predicate> then <then> else <else>}
    \item when: \ihaskell{when <predicate> <then>}
    \item unless: \ihaskell{unless <predicate> <else>}
  \end{itemize}

  \begin{lstlisting}[language=Haskell]
if True then 1 else 2 ; => 1
when True 1 ; => 1
unless False 1 ; => 1

-- equivalent to
if True then 1 else 2 ; => 1
if True then 1 ; => 1
if False then 1 ; => ()

-- equivalent to
if True then 1 else 2 ; => 1
if False then 2 else 1 ; => 1
\end{lstlisting}

  \subsubsection{Loops}

  \begin{itemize}
    \item for in a range: \ihaskell{for <var> <- [<start>..<end>] <body>}
    \item for over lists: \ihaskell{for <var> <- <list> <body>}
    \item for is available for other collections
  \end{itemize}

  \begin{lstlisting}[language=Haskell]
for i <- [1..10] do
print i ; => 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
for i <- [1..10], i `mod` 2 == 0 do
print i ; => 2, 4, 6, 8, 10
\end{lstlisting}

  \breakcolumn

  \subsection{Monads}

  \begin{itemize}
    \item Monads are used to encapsulate side effects
    \item the \ihaskell{do} notation is used to chain monadic actions
  \end{itemize}

  \begin{lstlisting}[language=Haskell]
comb :: Maybe a -> (a -> Maybe b) -> Maybe b
comb Nothing _ = Nothing
comb (Just x) f = f x
\end{lstlisting}

  \subsubsection{Foldable}

  \begin{itemize}
    \item used for folding (either \ihaskell{foldl} or \ihaskell{foldr})
    \item given a container and a binary operation \ihaskell{f}, applies \ihaskell{f} to each element of the container
    \item syntax: \ihaskell{foldr <function> <accumulator> <container>}
  \end{itemize}

  \begin{lstlisting}[language=Haskell]
foldr (+) 0 [1, 2, 3] ; => 6
foldr (*) 1 [1, 2, 3] ; => 6
\end{lstlisting}

  \begin{lstlisting}[language=Haskell]
data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)

instance Foldable Tree where
  foldr f z Empty = z
  foldr f z (Leaf x) = f x z
  foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l
\end{lstlisting}

  \subsubsection{Functor}

  \begin{itemize}
    \item used for mapping (via \ihaskell{fmap})
    \item signature of \ihaskell{fmap}: \ihaskell{fmap :: (a -> b) -> f a -> f b}
  \end{itemize}

  \begin{lstlisting}[language=Haskell]
instance Functor Tree where
    fmap f Empty = Empty
    fmap f (Leaf x) = Leaf (f x)
    fmap f (Node l r) = Node (fmap f l) (fmap f r)
\end{lstlisting}

  \breakcolumn

  \subsubsection{Applicative}

  \begin{itemize}
    \item used for applying a function in a context (via \ihaskell{<*>})
    \item is applied to type constructors that are parametric with one parameter
  \end{itemize}

  \begin{lstlisting}[language=Haskell]
instance Applicative Maybe where
    pure = Just
    (Just f) <*> something = fmap f something
    Nothing <*> _ = Nothing
\end{lstlisting}

  \begin{itemize}
    \item \ihaskell{pure} takes a value and returns an applicative (\ihaskell{f}) with that value
    \item \ihaskell{<*>} takes an applicative (\ihaskell{f}) with a function and another applicative (\ihaskell{g}) and returns an applicative (\ihaskell{h}) with the result of applying the function to the value of \ihaskell{g}
  \end{itemize}

  \subsubsection{Monad}

  \begin{itemize}
    \item used for sequencing (via \ihaskell{>>=})
    \item signature of:
          \begin{itemize}
            \item \ihaskell{>>=}: \ihaskell{(>>=) :: m a -> (a -> m b) -> m b}
            \item \ihaskell{>>}: \ihaskell{(>>) :: m a -> m b -> m b}
            \item \ihaskell{return}: \ihaskell{return :: a -> m a}
          \end{itemize}
    \item meaning of:
          \begin{itemize}
            \item \ihaskell{>>=}: \ihaskell{m a} is a monadic action that returns a value of type \ihaskell{a}
            \item \ihaskell{f} is a function that takes a value of type \ihaskell{a} and returns a monadic action that returns a value of type \ihaskell{b}
            \item \ihaskell{>>=} returns a monadic action that returns a value of type \ihaskell{b}
          \end{itemize}
    \item \ihaskell{do} notation is used to chain monadic actions, it is translated into \ihaskell{>>=} and \ihaskell{>>}
    \item \ihaskell{do} notation is available for all monads
  \end{itemize}

  \begin{lstlisting}[language=Haskell]
instance Monad Maybe where
    return = Just
    Nothing >>= _ = Nothing
    (Just x) >>= f = f x
\end{lstlisting}

  \breakcolumn

  \subsection{Type classes}

  \begin{itemize}
    \item type classes are defined via \ihaskell{class}
    \item type classes are instantiated via \ihaskell{instance}
  \end{itemize}

  \subsubsection{Polymorphism}

  \begin{itemize}
    \item type class constraints are resolved at compile time
    \item parametric polymorphism: \ihaskell{<name> :: <type> -> <type>}
    \item ad-hoc polymorphism: \ihaskell{<name> :: <type class> => <type> -> <type>}
  \end{itemize}

  \begin{lstlisting}[language=Haskell]
-- parametric polymorphism
id :: a -> a
id x = x

-- ad-hoc polymorphism
(+) :: Num a => a -> a -> a
x + y = x + y
  \end{lstlisting}

\end{multicols*}

\clearpage

\begin{multicols*}{2}

  \section{Erlang}

  \subsection{Syntax}

  \begin{itemize}
    \item period \ierlang{.} terminates expressions`'
    \item semicolon \ierlang{;} separates expressions branches and clauses
    \item comma \ierlang{,} separates alternate clauses
  \end{itemize}

  \subsection{Comments}

  \begin{itemize}
    \item single line comment: \ierlang{\%}
    \item multi line comments are not supported
  \end{itemize}

  \begin{lstlisting}[language=Erlang]
% single line comment
%% sometimes the double percent is used
\end{lstlisting}

  \subsection{Data types}

  \begin{itemize}
    \item term: any Erlang data
    \item integer: \ierlang{1, 2, 3}
    \item float: \ierlang{1.0, 2.0, 3.0}
    \item binary, hexadecimal and octal numbers: \ierlang{2#101, 16#FF, 8#377}
    \item atoms: \ierlang{atom} \textit{(see \ref{sec:erlang-atoms})}
    \item bit strings: \ierlang{<<"hello">>}
    \item strings: \ierlang{"hello"}
  \end{itemize}

  \subsubsection{Atoms}
  \label{sec:erlang-atoms}

  \begin{itemize}
    \item any sequence of letters, digits, underscore, at sign, dollar sign and full stop
    \item atoms are used to represent constants
    \item syntax: \ierlang{<atom>} or \ierlang{'<atom>'}
    \item if unquoted, atoms can contain only lowercase letters, digits and underscore
  \end{itemize}

  \begin{lstlisting}[language=Erlang]
atom ; => atom
'atom' ; => atom
'ATOM' ; => 'ATOM'
\end{lstlisting}

  \breakcolumn

  \subsection{Functions}

  \begin{itemize}
    \item functions are defined as sequences of equations
          \begin{itemize}
            \item arguments are matched with the right parts of equations, top to bottom
            \item if the match succeeds, the function body is called
          \end{itemize}
    \item functions have boolean guards \ierlang{when <predicate> -> <then>}
          \begin{itemize}
            \item guards are evaluated in constant time
          \end{itemize}
  \end{itemize}

  \begin{lstlisting}[language=Erlang]
    factorial(0) -> 1;
    factorial(N) when N > 0 -> N * factorial(N - 1).
  \end{lstlisting}

  \subsubsection{Apply}

  \begin{itemize}
    \item syntax: \ierlang{apply(<module>, <function>, <arguments>)}
    \item any expression can be used as a function
    \item the function is applied to the arguments
    \item \ierlang{\$MODULE} is a macro that expands to the name of the current module
  \end{itemize}

  \begin{lstlisting}[language=Erlang]
% assumption:factorial is defined in the current module
apply($MODULE, factorial, [5]) ; => 120
\end{lstlisting}

  \subsubsection{Function Guards}

  \begin{itemize}
    \item \ierlang{X} is a number: \ierlang{number(X)}
    \item \ierlang{X} is an integer: \ierlang{integer(X)}
    \item \ierlang{X} is a float: \ierlang{float(X)}
    \item \ierlang{X} is an atom: \ierlang{atom(X)}
    \item \ierlang{X} is a list: \ierlang{is_list(X)}
    \item \ierlang{X} is a tuple: \ierlang{is_tuple(X)}
    \item \ierlang{X} is a map: \ierlang{is_map(X)}
    \item \ierlang{X} is greater than \ierlang{Y}: \ierlang{X > Y}
    \item \ierlang{X} is less than \ierlang{Y}: \ierlang{X < Y}
    \item \ierlang{X} is exactly equal to \ierlang{Y}: \ierlang{X =:= Y}
    \item \ierlang{X} is equal to \ierlang{Y} when converted to the \texttt{int}: \ierlang{X == Y}
    \item \ierlang{X} is not equal to \ierlang{Y}: \ierlang{X =/= Y}
    \item \ierlang{X} is a list of length \ierlang{N}: \ierlang{length(X) =:= N}
    \item \ierlang{X} is a tuple of length \ierlang{N}: \ierlang{size(X) =:= N}
  \end{itemize}

  \breakcolumn

  \subsubsection{Function Calls}

  \begin{itemize}
    \item function and modules names must be atoms
    \item function call \ierlang{<name>(<arg1>, <arg2>, ...)}
    \item alternative \ierlang{<module>:<name>(<arg1>, <arg2>, ...)}
    \item use \ierlang{-import} to avoid specifying the module name
  \end{itemize}

  \begin{lstlisting}[language=Erlang]
my_module:my_function(1, 2, 3) ; => 6
-import(my_module, [my_function/3]).
my_function(1, 2, 3) ; => 6
\end{lstlisting}

  \subsection{Variables}

  \begin{itemize}
    \item variables are immutable and can be bound only once
    \item variables start with an uppercase letter
    \item there is no keyword for variable declaration
  \end{itemize}

  \begin{lstlisting}[language=Erlang]
X = 5 ; => X = 5
A_very_long_variable_name = 5 ; => A_very_long_variable_name = 5
  \end{lstlisting}

  \subsection{Collections}

  \subsubsection{Lists}

  \begin{itemize}
    \item lists are composed of pairs
    \item lists are immutable
    \item manual definition: \ierlang{[1, 2, 3]}
    \item empty list: \ierlang{[]}
  \end{itemize}

  \begin{lstlisting}[language=Erlang]
[1, 2, 3] ; => [1, 2, 3]
[1, [2, 3]] ; => [1, [2, 3]]
\end{lstlisting}

  \breakcolumn

  \paragraph{Operations on lists}

  \begin{itemize}
    \item list length: \ierlang{length(<list>)}
    \item add an element at the beginning: \ierlang{[<element> | <list>]}
    \item add an element at the end: \ierlang{<list> ++ [<element>]}
    \item get the first element: \ierlang{lists:first(<list>)}
    \item get the last element: \ierlang{lists:last(<list>)}
    \item get the n-th element: \ierlang{lists:nth(<position>, <list>)}
    \item get the first n elements: \ierlang{lists:sublist(<list>, 0, <n>)}
    \item append two lists: \ierlang{lists:append(<list1>, <list2>)}
    \item concatenate two lists: \ierlang{<list1> ++ <list2>}
    \item delete the first occurrence of an element: \ierlang{lists:delete(<element>, <list>)}
    \item delete the last element of a list: \ierlang{lists:droplast(<list>)}
    \item delete the first element of a list: \ierlang{lists:drop(<list>)}
    \item apply a filter: \ierlang{lists:filter(<predicate>, <list>)}
    \item flatten a list: \ierlang{lists:flatten(<list>)}

    \item call a function on each element: \ierlang{lists:foreach(<function>, <list>)}
    \item map a function on each element: \ierlang{lists:map(<function>, <list>)}
    \item find the maximum element: \ierlang{lists:max(<list>)}
    \item find the minimum element: \ierlang{lists:min(<list>)}
  \end{itemize}

  \paragraph{Lists folding}

  \begin{itemize}
    \item fold a list from the left: \ierlang{lists:foldl(<function>, <accumulator>, <list>)}
    \item fold a list from the right: \ierlang{lists:foldr(<function>, <accumulator>, <list>)}
  \end{itemize}

  \begin{lstlisting}[language=Erlang]
lists:foldl(fun(X, Acc) -> X + Acc end, 0, [1, 2, 3]) ; => 6
lists:foldr(fun(X, Acc) -> X + Acc end, 0, [1, 2, 3]) ; => 6
\end{lstlisting}

  \subsubsection{Tuples}

  \begin{itemize}
    \item tuples are immutable
    \item tuples can be nested
    \item syntax: \ierlang{\{<element1>, <element2>, ...\}}
  \end{itemize}

  \begin{lstlisting}[language=Erlang]
{1, 2, 3} ; => {1, 2, 3}
{1, {2, 3}} ; => {1, {2, 3}}
\end{lstlisting}

  \breakcolumn

  \subsubsection{Records}

  \begin{itemize}
    \item records are tuples with named fields
    \item records are defined via \ierlang{-record(<name>, {<field1>, <field2>, ...})}
    \item records are accessed via \ierlang{#<name>.<field>}
  \end{itemize}

  \begin{lstlisting}[language=Erlang]
-record(point, {x, y}).
#point.x ; => x
\end{lstlisting}

  \subsubsection{Maps}

  \begin{itemize}
    \item maps are defined via \ierlang{\#{<key> => <value>, <key> => <value>, ...}}
    \item keys are accessed via \ierlang{<map>.<key>}
    \item maps are updated:
          \begin{itemize}
            \item to add or overwrite a key-value pair: \ierlang{<map>#{<key> => <value>}}
            \item to only update an existing key-value pair: \ierlang{<map>#{<key> := <value>}}
          \end{itemize}
  \end{itemize}

  \begin{lstlisting}[language=Erlang]
Map = #{a => 1, b => 2} % => #{a => 1, b => 2}
Map#{c => 3} % => #{a => 1, b => 2, c => 3}
Map#{a := 2} % => #{a => 2, b => 2}
Map#{d := 4} % => error
\end{lstlisting}

  \subsection{Control flow}

  \subsubsection{Conditionals}

  \paragraph{Pattern matching}

  \begin{itemize}
    \item the matching process is done top to bottom, left to right
    \item patterns may have boolean guards
    \item character \ierlang{_} matches everything \textit{(don't care)}
  \end{itemize}

  \begin{lstlisting}[language=Erlang]
sign(X) when X > 0 -> 1;
sign(X) when X < 0 -> -1;
sign(_) -> 0.
  \end{lstlisting}

  \breakcolumn

  \paragraph{if}

  \begin{itemize}
    \item syntax: \ierlang{if <predicate> -> <then>; <predicate> -> <then>; ... end}
    \item the \ierlang{true} pattern matches everything
    \item function guards are necessary
  \end{itemize}

  \begin{lstlisting}[language=Erlang]
if
    integer(X) -> integer_to_list(X);
    float(X) -> float_to_list(X);
    true -> "error" % this is the default case
end.
  \end{lstlisting}

  \paragraph{case}

  \begin{itemize}
    \item syntax: \ierlang{case <value> of <pattern> -> <then>; <pattern> -> <then>; ... end}
    \item the \ierlang{true} pattern matches everything
    \item function guards are not required
  \end{itemize}

  \begin{lstlisting}[language=Erlang]
case X of
    0 -> "zero";
    1 -> "one";
    true -> "other"
end.
  \end{lstlisting}

  \subsubsection{Loops}

  \begin{itemize}
    \item loops must be implemented via recursion
  \end{itemize}

  \paragraph{while}

  \begin{itemize}
    \item syntax: \ierlang{while(<predicate>) -> <then>; ...}
  \end{itemize}

  \begin{lstlisting}[language=Erlang]
while(X) ->
    if
        X > 0 -> io:format("~p~n", [X]),
        while(X - 1);
        true -> ok.
    end.
  \end{lstlisting}

  \breakcolumn

  \paragraph{for}

  \begin{itemize}
    \item syntax: \ierlang{for(<variable>) -> <then>; ...}
  \end{itemize}

  \begin{lstlisting}[language=Erlang]
for(X) ->
    for(X, 0).

for(X, N) when N < X ->
    io:format("~p~n", [N]),
    for(X, N + 1);
for(_, _) ->
    ok.
  \end{lstlisting}

  \subsection{Concurrent programming}

  \begin{itemize}
    \item processes are created via \ierlang{spawn(<module>, <function>, <arguments>)}
    \item processes are identified via \ierlang{Pid}
    \item messages are sent via \ierlang{Pid \! <message>}
    \item messages are received via \ierlang{receive <pattern> -> <then>; ... end}
  \end{itemize}

  \subsection{Examples}

  This section is not present for other languages, but I feel like there's no other way to explain important concepts (for the exam) in Erlang.

  \subsubsection{Echo process}

  \begin{lstlisting}[language=Erlang]
-module(echo).
-export([start/0, loop/0]).

start() ->
  Pid2 = spawn(echo, loop, []),
  Pid2 ! {self(), hello},

  receive
    {Pid2, Msg} -> io:format("received ~p~n", [Msg])
  end.

Pid2 ! stop.

loop() ->
  receive
    {From, Msg} ->
      From ! {self(), Msg},
    loop();
    stop ->
      true
  end.
\end{lstlisting}

  \subsubsection{Client-server}

  \begin{itemize}
    \item requests have syntax \ierlang{\{request, <data>\}}
    \item responses have syntax \ierlang{\{response, <data>\}}
  \end{itemize}

  \begin{lstlisting}[language=Erlang]
%% this snippet contains the server code
-module(my_server).
-export([start/0, server/1]).
server(Data) ->
  receive
    {From, {request, X}} ->
      {R, Data1} = handle(X, Data),
      % note: handle function is defined elsewhere
      From ! {my_server, {response, R}},
      server(Data1);
    {From, stop} ->
      From ! {my_server, stopped}
  end.
\end{lstlisting}

  \begin{lstlisting}[language=Erlang]
%% this snippet contains the client code
-module(my_client).
-export([start/0, client/1]).
client(Server) ->
  Server ! {self(), {request, 1}},
  receive
    {my_server, {response, R}} ->
      io:format("received ~p~n", [R])
  end.

client(Server) ->
  Server ! {self(), stop},
  receive
    {my_server, stopped} ->
      ok
  end.

start() ->
  Server = spawn(my_server, server, []),
  spawn(my_client, client, [Server]).
\end{lstlisting}

\end{multicols*}

\clearpage

\begin{multicols*}{2}

  \section{Latest version, Credits and License}

  \subsection{Latest version}

  The latest version of this document is available at \url{https://github.com/lorossi/principles-of-programming-languages-reference}.
  This document has been compiled on \today.

  If you see any error, want to contribute or have any suggestion, feel free to open an issue or a pull request there!

  \subsection{Credits}

  Some of the examples of the code are taken from the slides provided by the professor and his lesson of \textit{Principles of Programming Languages} by Politecnico di Milano, Prof. Matteo Pradella.

  \subsection{License}

  The content of this document is licensed under the Creative Commons Attribution-ShareAlike 4.0 International License. To view a copy of this license, visit \url{https://creativecommons.org/licenses/by-sa/4.0/}
  \ccbysa

  All the source code in this document and the snippets included in the repository are licensed under the MIT License. To view a copy of this license, visit \url{https://opensource.org/licenses/MIT}.

\end{multicols*}

\end{document}