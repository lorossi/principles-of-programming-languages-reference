\documentclass[a4paper,landscape,10pt]{article}
\usepackage{settings}

\begin{document}

\section{Racket}
\begin{multicols*}{2}
  \subsection{Comments}

  \begin{lstlisting}[language=Racket]
; single line comment
#|
  multi-line-comment
	can span
	multiple lines
  end of comment
|#
\end{lstlisting}

  \subsection{Datum evaluation}

  \begin{itemize}
    \item \lstinline[language=Racket]!(quote <datum>)! or \lstinline[language=Racket]!'<datum>! leaves the datum as-is
    \item \lstinline[language=Racket]!(unquote <datum>)! or \lstinline[language=Racket]!,<datum>! is the opposite of \lstinline[language=Racket]!quote!
    \item \lstinline[language=Racket]!(quasiquote <datum>)! or \lstinline[language=Racket]!,@<datum>! allows to apply the unquote where needed
  \end{itemize}

  \begin{lstlisting}[language=Racket]
'(1 2 3); => (1 2 3)
(1 ,(+ 1 1) 3) ; => '(1 2 3)
\end{lstlisting}

  \subsection{Predicates}

  \begin{itemize}
    \item all predicates end with \lstinline[language=Racket]!?!
    \item checks if a number is even: \lstinline[language=Racket]!even?!
    \item checks if a number is odd: \lstinline[language=Racket]!odd?!
    \item check if a datum is true: \lstinline[language=Racket]!true?!
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(even? 2) ; => #t
(odd? 2) ; => #f
(true? #t) ; => #t
\end{lstlisting}

  \switchcolumn

  \subsubsection{Equivalence}

  \begin{itemize}
    \item check if two numbers are equal: \lstinline[language=Racket]!=!
    \item checks if two objects or numbers are the same: \lstinline[language=Racket]!eq?!
    \item checks if two objects are the same: \lstinline[language=Racket]!eqv?!
    \item checks if two objects are the same: \lstinline[language=Racket]!equal?!
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(= 1 1) ; => #t
(eq? 1 1) ; => #t
(eqv? 1 1) ; => #t
(equal? 1 1) ; => #t
\end{lstlisting}

  \subsection{Data types}

  \begin{itemize}
    \item integer: \lstinline[language=Racket]!9125!
    \item binary: \lstinline[language=Racket]!#b10001110100101!
    \item octal: \lstinline[language=Racket]!#o21645!
    \item hexadecimal: \lstinline[language=Racket]!#x23a5!
    \item real: \lstinline[language=Racket]!91.25!
    \item rational: \lstinline[language=Racket]!91/25!
    \item complex: \lstinline[language=Racket]!91+25i!
    \item boolean: \lstinline[language=Racket]!#t, #f!
    \item character: \lstinline[language=Racket]!#\A, #\$\lambda$, #\u30BB!
    \item string: \lstinline[language=Racket]!"Hello, world!"!
    \item null element: \lstinline[language=Racket]!'(), null!
    \item lists: \lstinline[language=Racket]!'(1 2 3)!
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(define x 5) ; => x = 5
(define y "Hello, world!") ; => y = "Hello, world!"
(define z #t) ; => z = #t
null ; => '()
\end{lstlisting}

  \switchcolumn

  \subsubsection{Basic operations}

  All the operators are in the form \lstinline[language=Racket]!(<operator> <operand> ...)! \textit{(prefix notation).}

  \paragraph{Operations on numbers}

  \begin{itemize}
    \item arithmetic operations: \lstinline[language=Racket]!+!, \lstinline[language=Racket]!-!, \lstinline[language=Racket]!*!, \lstinline[language=Racket]!/!
    \item exponentiation: \lstinline[language=Racket]!exp!
    \item quotient: \lstinline[language=Racket]!quotient!
    \item remainder: \lstinline[language=Racket]!remainder!
    \item add \(1\): \lstinline[language=Racket]!add1!
    \item subtract \(1\): \lstinline[language=Racket]!sub1!
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(+ 1 2 3) ; => 6
(- 1 2 3) ; => -4
(quotient 5 2) ; => 2
(remainder 5 2) ; => 1
(add1 5) ; => 6
(sub1 5) ; => 4
\end{lstlisting}

  \paragraph{Operations on strings}

  \begin{itemize}
    \item string length: \lstinline[language=Racket]!string-length!
    \item string append: \lstinline[language=Racket]!string-append!
    \item string to list: \lstinline[language=Racket]!string->list!
    \item list to string: \lstinline[language=Racket]!list->string!
    \item get n-th character: \lstinline[language=Racket]!string-ref!
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(string-length "Hello, world!") ; => 13
(string-append "Hello, " "world!") ; => "Hello, world!"
(string->list "Hello") ; => '(#\H #\e #\l #\l #\o)
(list->string '(#\H #\e #\l #\l #\o)) ; => "Hello"
(string-ref "Hello" 0) ; => #\H
\end{lstlisting}

  \switchcolumn

  \paragraph{Operations on bools}

  \begin{itemize}
    \item logic operations: \lstinline[language=Racket]!and!, \lstinline[language=Racket]!or!, \lstinline[language=Racket]!not!, \lstinline[language=Racket]!xor!
    \item implication: \lstinline[language=Racket]!implies!
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(and #t #f) ; => #f
(or #t #f) ; => #t
(not #t) ; => #f
(xor #t #f) ; => #t
(implies #t #f) ; => #f
\end{lstlisting}

  \subsection{Functions}

  \begin{itemize}
    \item anonymous functions: \lstinline[language=Racket]!(lambda (<arg1> <arg2> ...) <body>)!
    \item named functions: \lstinline[language=Racket]!(define (<name> <arg1> <arg2> ...) <body>)!
    \item old way: \lstinline[language=Racket]!(define <name> (lambda (<arg1> <arg2> ...) <body>))!
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(lambda (x) (+ x 1)) ;
(define (add1 x) (+ x 1)) ;
\end{lstlisting}

  \subsubsection{Higher order functions}

  \begin{itemize}
    \item apply a function to each element of a list: \lstinline[language=Racket]!map!
    \item apply a filter: \lstinline[language=Racket]!filter!
    \item apply a function to each element of a list and flatten the result: \lstinline[language=Racket]!apply!
    \item fold a list: \lstinline[language=Racket]!foldl!, \lstinline[language=Racket]!foldr!
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(map add1 '(1 2 3)) ; => '(2 3 4)
(filter even? '(1 2 3 4)) ; => '(2 4)
(apply append '((1 2) (3 4))) ; => '(1 2 3 4)
(foldl + 0 '(1 2 3)) ; => 6
(foldr + 0 '(1 2 3)) ; => 6
\end{lstlisting}


  \subsection{Variables}

  \begin{itemize}
    \item parallel binding: \lstinline[language=Racket]!let!
    \item serial binding: \lstinline[language=Racket]!let*!
    \item recursive binding: \lstinline[language=Racket]!letrec!
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(let ((x 5) (y 2)) (list x y)) ; => '(5 2)
(let* ((x 1) (y (add1 x))) (list x y)) ; // '(1 2)
\end{lstlisting}

  \switchcolumn

  \subsection{Collections}

  \subsubsection{Structs}

  \begin{itemize}
    \item definition: \lstinline[language=Racket]!(struct <struct-name> (<field> ...))!
    \item constructor: \lstinline[language=Racket]!(define <name> <struct-name> <field-value> ...)!
    \item getter: \lstinline[language=Racket]!<struct-name>-<field-name>!
    \item setter: \lstinline[language=Racket]!set-<struct-name>-<field-name>!!
    \item predicate: \lstinline[language=Racket]!<struct-name>?!
    \item structs and fields are immutable by default
    \item use \lstinline[language=Racket]!#:mutable! keyword on struct or field to make it mutable
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(struct point (x y)) ; => point
(define p (point 1 2)) ; => p = (point 1 2)
(point-x p) ; => 1
(point? p) ; => #t

(struct mut-point (x y #:mutable)) ; => point
(define mp (mut-point 1 2)) ; => mp = (mut-point 1 2)
(set-mut-point-x! mp 5) ; => mp = (mut-point 5 2)
\end{lstlisting}

  \subsubsection{Pairs}

  \begin{itemize}
    \item definition: \lstinline[language=Racket]!(cons <first> <second>)!
    \item getter of first element: \lstinline[language=Racket]!car!
    \item getter of second element: \lstinline[language=Racket]!cdr!
    \item car and cdr can be composed \textit{(\lstinline[language=Racket]!cdadadr!, \lstinline[language=Racket]!caaar!)}
    \item pairs are immutable
  \end{itemize}

  \begin{lstlisting}[language=Racket, morekeywords={caar, cadr, cdar, cddr}]
(cons 1 2) ; => '(1 . 2)
(car '(1 . 2)) ; => 1
(cdr '(1 . 2)) ; => 2
(caar '((1 . 2) . 3)) ; => 1
(cadr '((1 . 2) . 3)) ; => 2
(cdar '((1 . 2) . 3)) ; => 2
(cddr '((1 . 2) . 3)) ; => 3
\end{lstlisting}

  \subsubsection{Lists}

  \begin{itemize}
    \item lists are composed of pairs
    \item manually defined via \lstinline[language=Racket]!quote!: \lstinline[language=Racket]!'(1 2 3)!
    \item empty list: \lstinline[language=Racket]!'()!
    \item lists are made by pairs
          \begin{itemize} \item the \lstinline[language=Racket]!car! contains the first value
            \item the \lstinline[language=Racket]!cdr! contains the the rest of the list
            \item the last pair has \lstinline[language=Racket]!cdr! equal to \lstinline[language=Racket]!'()!
          \end{itemize}
  \end{itemize}

  \begin{lstlisting}[language=Racket]
'(1 2 3) ; => '(1 2 3)
'(1 . (2 . (3 . ()))) ; => '(1 2 3)
\end{lstlisting}

  \paragraph{Operations on lists}

  \begin{itemize}
    \item list length: \lstinline[language=Racket]!length!
    \item add an element at the beginning: \lstinline[language=Racket]!cons!
    \item add an element at the end: \lstinline[language=Racket]!append!
    \item take the first element: \lstinline[language=Racket]!first!
    \item take the last element: \lstinline[language=Racket]!last!
    \item take the n-th element: \lstinline[language=Racket]!list-ref <list> <n>!
    \item take the n-th element after pos: \lstinline[language=Racket]!list-tail <list> <pos>!
    \item count the occurrences of an element: \lstinline[language=Racket]!count <predicate> <list>!
    \item apply a filter: \lstinline[language=Racket]!filter <predicate>!
    \item apply a function to each element: \lstinline[language=Racket]!map <function>!
    \item get the reverse of a list: \lstinline[language=Racket]!reverse!
    \item get the elements after the first: \lstinline[language=Racket]!rest!
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(length '(1 2 3)) ; => 3
(cons 1 '(2 3)) ; => '(1 2 3)
(append '(1 2) '(3 4)) ; => '(1 2 3 4)
(first '(1 2 3)) ; => 1
(last '(1 2 3)) ; => 3
(list-ref '(1 2 3) 1) ; => 2
(list-tail '(1 2 3) 1) ; => '(2 3)
(count even? '(1 2 3 4)) ; => 2
(filter even? '(1 2 3 4)) ; => '(2 4)
(map add1 '(1 2 3)) ; => '(2 3 4)
(reverse '(1 2 3)) ; => '(3 2 1)
(rest '(1 2 3)) ; => '(2 3)
\end{lstlisting}

  \vfill

  \paragraph{Lists folding}

  \begin{itemize}
    \item lists can be folded from the left with \lstinline[language=Racket]!foldl!
    \item lists can be folded from the right with \lstinline[language=Racket]!foldr!
    \item the accumulator is the first argument of the function
    \item the list is the second argument of the function
    \item the function is applied to the accumulator and the first element of the list
  \end{itemize}

  \begin{lstlisting}[language=Racket]
(foldl + 0 '(1 2 3 4)) ; => 10
(foldr * 1 '(1 2 3 4)) ; => 24
  \end{lstlisting}

  \subsubsection{Vectors}

  \begin{itemize}
    \item definition: \lstinline[language=Racket]!#(<element> ...)!
    \item getter: \lstinline[language=Racket]!vector-ref!
    \item vector are immutable, fixed size and zero-indexed
  \end{itemize}

  \begin{lstlisting}[language=Racket]
#(1 2 3) ; => '#(1 2 3)
(vector-ref '#(1 2 3) 0) ; => 1
  \end{lstlisting}

  \subsubsection{Sets}

  \dots

  \subsubsection{Hash}

  \dots

  \subsection{Control flow}

  \subsubsection{Conditionals}

  \paragraph{if}

  \dots

  \paragraph{cond}

  \dots

  \paragraph{pattern matching}

  \dots

  \subsection{Object Oriented}

  \dots

\end{multicols*}

\clearpage

\section{Erlang}

\clearpage

\section{Haskell}


\end{document}