\documentclass[a4paper,landscape,10pt]{article}

\usepackage{settings}

% TODO: when everything has been written, space correctly the content by breaking the columns via the (custom)\breakcolumn command

\begin{document}

\section{Racket}
\begin{multicols*}{2}
  \subsection{Comments}

  \begin{itemize}
    \item single line comment: \iracket{;}
    \item multi-line comment: \iracket{\#| ... |\#}
    \item multi-line comments can be nested
  \end{itemize}

  \begin{racket}
    ; single line comment
    #|
    multi-line-comment
    can span
    multiple lines
    end of comment
    |#
  \end{racket}

  \subsection{Data types}

  \begin{itemize}
    \item typing is dynamic
    \item types:
          \begin{itemize}
            \item boolean: \iracket{#\\t, #\\f}
            \item integer: \iracket{9125}
            \item binary: \iracket{#b10001110100101}
            \item octal: \iracket{#o21645}
            \item hexadecimal: \iracket{#x23a5}
            \item real: \iracket{91.25}
            \item rational: \iracket{91/25}
            \item complex: \iracket{91+25i}
            \item character: \lstinline[language=CustomRacket, mathescape=true]!#\A, #\$\lambda$, #\u30BB!
            \item null element: \iracket{'(), null}
            \item string: \iracket{"Hello, world!"}
          \end{itemize}
  \end{itemize}

  \begin{racket}
(define x 5) ; => x = 5
(define y "Hello, world!") ; => y = "Hello, world!"
(define z #\t) ; => z = #\t
(define w #\A) ; => w = #\A
null ; => '()
\end{racket}

  \breakcolumn

  \subsection{Variables}

  \begin{itemize}
    \item variables are immutable
    \item parallel binding: \iracket{let}
    \item serial binding: \iracket{let*}
    \item recursive binding: \iracket{letrec}
  \end{itemize}

  \begin{racket}
(let ((x 5) (y 2)) (printf "~a ~a~n" x y)) ; => 5 2
(let* ((x 1) (y (add1 x))) (printf "~a ~a~n" x y)) ; => 1 2
\end{racket}

  \subsubsection{Datum evaluation}

  \begin{itemize}
    \item \iracket{quote <datum>} or \iracket{'<datum>} leaves the datum as-is
    \item \iracket{unquote <datum>} or \iracket{,<datum>} is the opposite of \iracket{quote}
    \item \iracket{quasiquote <datum>} or \iracket{,@<datum>} allows to apply the unquote where needed
  \end{itemize}

  \begin{racket}
'(1 2 3); => (1 2 3)
(1 ,(+ 1 1) 3) ; => '(1 2 3)
  \end{racket}

  \subsubsection{Equivalence}

  \begin{itemize}
    \item numbers equivalence: \iracket{=}
    \item objects or numbers equivalence: \iracket{eq?}
    \item objects equivalence: \iracket{eqv?}
    \item objects equivalence: \iracket{equal?}
  \end{itemize}

  \begin{racket}
(= 1 1) ; => #\t
(eq? 1 0) ; => #\f
(eqv? 'yes 'yes) ; => #\t
(equal? 'yes 'no) ; => #\f
\end{racket}

  \subsubsection{Basic operations}

  \begin{itemize}
    \item all operations are in prefix notation \iracket{<operator> <operand> ...}
  \end{itemize}

  \breakcolumn

  \paragraph{Operations on numbers}

  \begin{itemize}
    \item arithmetic operations: \iracket{+}, \iracket{-}, \iracket{*}, \iracket{/}
    \item exponentiation: \iracket{expt}
    \item exponentiation by \(e\): \iracket{exp}
    \item logarithm: \iracket{log}
    \item quotient: \iracket{quotient}
    \item remainder: \iracket{remainder}
    \item largest and smallest of two numbers: \iracket{max}, \iracket{min}
    \item add \(1\): \iracket{add1}
    \item subtract \(1\): \iracket{sub1}
    \item greatest common divisor: \iracket{gcd}
    \item least common multiple: \iracket{lcm}
  \end{itemize}

  \begin{racket}
(+ 1 2 3) ; => 6
(- 1 2 3) ; => -4
(expt 2 3) ; => 8
(exp 2) ; => e ** 2 = 7.38905609893065
(log 10) ; => 2.302585092994046
(quotient 5 2) ; => 2
(remainder 5 2) ; => 1
(max 1 2) ; => 2
(min 1 2) ; => 1
(add1 5) ; => 6
(sub1 5) ; => 4
(gcd 12 18) ; => 6
(lcm 12 18) ; => 36
\end{racket}

  \paragraph{Operations on strings}

  \begin{itemize}
    \item string length: \iracket{string-length}
    \item string append: \iracket{string-append}
    \item string to list: \iracket{string->list}
    \item list to string: \iracket{list->string}
    \item get n-th character: \iracket{string-ref}
  \end{itemize}

  \begin{racket}
(string-length "Hello, world!") ; => 13
(string-append "Hello, " "world!") ; => "Hello, world!"
(string->list "Hello") ; => '(#\H #\e #\l #\l #\o)
(list->string '(#\H #\e #\l #\l #\o)) ; => "Hello"
(string-ref "Hello" 0) ; => #\H
\end{racket}

  \paragraph{Operations on bools}

  \begin{itemize}
    \item logic operations: \iracket{and}, \iracket{or}, \iracket{not}, \iracket{xor}
    \item implication: \iracket{implies}
  \end{itemize}

  \begin{racket}
(and #\t #\f) ; => #\f
(or #\t #\f) ; => #\t
(not #\t) ; => #\f
(xor #\t #\f) ; => #\t
(implies #\t #\f) ; => #\f
\end{racket}

  \subsubsection{Types conversion}

  \begin{itemize}
    \item inexact and exact: \iracket{inexact->exact}, \iracket{exact->inexact}
    \item integer and float: \iracket{integer->float}, \iracket{float->integer}
    \item integer and rational: \iracket{integer->rational}, \iracket{rational->integer}
    \item list and vector: \iracket{list->vector}, \iracket{vector->list}
    \item vector and string: \iracket{vector->string}, \iracket{string->vector}
  \end{itemize}

  \subsection{Predicates}

  \begin{itemize}
    \item all predicates end with \iracket{?}
    \item checks if a number is even: \iracket{even?}
    \item checks if a number is odd: \iracket{odd?}
    \item check if a datum is true: \iracket{true?}
    \item check if a datum is false: \iracket{false?}
    \item check if a number is positive: \iracket{positive?}
    \item check if a number is negative: \iracket{negative?}
    \item check if a number is zero: \iracket{zero?}
    \item check if an object is immutable \iracket{immutable?}
  \end{itemize}

  \begin{racket}
(even? 2) ; => #\t
(odd? 2) ; => #\f
(true? #\t) ; => #\t
(false? #\t) ; => #\f
(positive? 1) ; => #\t
(negative? 1) ; => #\f
(zero? 1) ; => #\f
\end{racket}

  \breakcolumn

  \subsection{Functions}

  \begin{itemize}
    \item anonymous functions: \iracket{lambda (<arg1> <arg2> ...) <body>}
    \item named functions: \iracket{define (<name> <arg1> <arg2> ...) <body>}
    \item old way: \iracket{define <name> (lambda (<arg1> <arg2> ...) <body>)}
  \end{itemize}

  \begin{racket}
; anonymous function
((lambda (x) (+ x 3)) 5); => 8
; named function
(define (add3 x) (+ x 3))
(add3 5) ; => 8
\end{racket}

  \subsubsection{Higher order functions}

  \begin{itemize}
    \item apply a function to each element of a list: \iracket{map <function> <list>}
    \item apply a filter: \iracket{filter <predicate> <list>}
    \item apply a function to each element of a list and flatten the result: \iracket{apply <function> <list>}
    \item fold a list: \iracket{foldl <function> <accumulator> <list>}
    \item fold a list: \iracket{foldr <function> <accumulator> <list>}
    \item \iracket{foldl} has space complexity \(O(1)\)
    \item \iracket{foldr} has space complexity \(O(n)\)
  \end{itemize}

  \begin{racket}
(map add1 '(1 2 3)) ; => '(2 3 4)
(filter even? '(1 2 3 4)) ; => '(2 4)
(apply append '((1 2) (3 4))) ; => '(1 2 3 4)
(foldl + 0 '(1 2 3)) ; => 6
(foldr + 0 '(1 2 3)) ; => 6
\end{racket}

  \subsection{Mutation}

  \begin{itemize}
    \item all mutators end with \iracket{\!}
    \item \iracket{set\!} is used to mutate variables
    \item \iracket{vector-set\!} is used to mutate vectors
  \end{itemize}

  \begin{racket}
(define x 5) ; => x = 5
(set! x 6) ; => x = 6
(define v (vector 2 2 3 4)) ; => v = '#(2 2 3 4)
(vector-set! v 0 1) ; => v = '#(1 2 3 4)
\end{racket}

  \breakcolumn

  \subsection{Collections}

  \subsubsection{Structs}

  \begin{itemize}
    \item definition: \iracket{struct <struct-name> (<field> ...)}
    \item constructor: \iracket{define <name> <struct-name> <field-value> ...}
    \item getter: \iracket{<struct-name>-<field-name>}
    \item setter: \iracket{set-<struct-name>-<field-name>\!}
    \item predicate: \iracket{<struct-name>?}
    \item structs and fields are immutable by default
    \item use \iracket{#:mutable} keyword on struct or field to make it mutable
  \end{itemize}

  \begin{racket}
(struct point (x y)) ; => point
(define p (point 1 2)) ; => p = (point 1 2)
(point-x p) ; => 1
(point? p) ; => #\t

(struct mut-point (x y #:mutable)) ; => point
(define mp (mut-point 1 2)) ; => mp = (mut-point 1 2)
(set-mut-point-x! mp 5) ; => mp = (mut-point 5 2)
\end{racket}

  \subsubsection{Pairs}

  \begin{itemize}
    \item definition: \iracket{cons <first> <second>}
    \item getter of first element: \iracket{car}
    \item getter of second element: \iracket{cdr}
    \item car and cdr can be composed: \iracket{cadddr}, \iracket{caaar}, \ldots
    \item check if a variable is a pair: \iracket{pair?}
    \item pairs are immutable
  \end{itemize}

  \begin{racket}
(cons 1 2) ; => '(1 . 2)
(car '(1 . 2)) ; => 1
(cdr '(1 . 2)) ; => 2
(pair? '(1 . 2)) ; => #\t
(pair? 1) ; => #\f
(caar '((1 . 2) . 3)) ; => 1
(cadr '((1 . 2) . 3)) ; => 2
(cdar '((1 . 2) . 3)) ; => 2
(cddr '((1 . 2) . 3)) ; => 3
\end{racket}

  \breakcolumn

  \subsubsection{Lists}

  \begin{itemize}
    \item lists are composed of pairs
    \item manually defined via \iracket{quote}: \iracket{'(1 2 3)}
    \item empty list: \iracket{'()}
    \item list of length \iracket{n}: \iracket{build-list <n> <procedure>}
    \item list of length \iracket{n} with initial value \iracket{<init>}: \iracket{make-list <n> <init>}
    \item lists are made by pairs
          \begin{itemize} \item the \iracket{car} contains the first value
            \item the \iracket{cdr} contains the the rest of the list
            \item the last pair has \iracket{cdr} equal to \iracket{'()}
          \end{itemize}
  \end{itemize}

  \begin{racket}
'(1 2 3) ; => '(1 2 3)
'(1 . (2 . (3 . ()))) ; => '(1 2 3)
(build-list 3 (lambda (x) (* x 2))) ; => '(0 2 4)
(make-list 3 7) ; => '(7 7 7)
\end{racket}

  \paragraph{Operations on lists}

  \begin{itemize}
    \item list length: \iracket{length}
    \item check if a variable is a list: \iracket{list?}
    \item check if a list is empty: \iracket{empty?}
    \item add an element at the beginning: \iracket{cons}
    \item add an element at the end: \iracket{append}
    \item get the elements after the first: \iracket{rest <list>}
    \item get the first element: \iracket{first}
    \item get the last element: \iracket{last}
    \item get the n-th element: \iracket{list-ref <list> <n>}
    \item get the elements after the n-th: \iracket{list-tail <list> <pos>}
    \item get the first n elements: \iracket{take <list> <n>}
    \item get the last n elements: \iracket{drop <list> <n>}
    \item count the occurrences of an element: \iracket{count <predicate> <list>}
    \item apply a filter: \iracket{filter <predicate> <list>}
    \item apply a function to each element: \iracket{map <function> <list>}
    \item get the reverse of a list: \iracket{reverse <list>}
  \end{itemize}

  \breakcolumn

  \begin{racket}
(length '(1 2 3)) ; => 3
(list? '(1 2 3)) ; => #\t
(empty? '(1 2 3)) ; => #\f
(cons 1 '(2 3)) ; => '(1 2 3)
(append '(1 2) '(3 4)) ; => '(1 2 3 4)
(first '(1 2 3)) ; => 1
(last '(1 2 3)) ; => 3
(list-ref '(1 2 3) 1) ; => 2
(list-tail '(1 2 3) 1) ; => '(2 3)
(take '(1 2 3) 2) ; => '(1 2)
(drop '(1 2 3) 1) ; => '(2 3)
(count even? '(1 2 3 4)) ; => 2
(filter even? '(1 2 3 4)) ; => '(2 4)
(map add1 '(1 2 3)) ; => '(2 3 4)
(reverse '(1 2 3)) ; => '(3 2 1)
(rest '(1 2 3)) ; => '(2 3)
\end{racket}

  \paragraph{Lists folding}

  \begin{itemize}
    \item lists can be folded from the left with \iracket{foldl}
    \item lists can be folded from the right with \iracket{foldr}
  \end{itemize}

  \begin{racket}
(foldl + 0 '(1 2 3 4)) ; => 10
(foldr * 1 '(1 2 3 4)) ; => 24
  \end{racket}

  \subsubsection{Vectors}

  \begin{itemize}
    \item definition: \iracket{#(<element> ...)}
    \item getter: \iracket{vector-ref}
    \item vector are immutable, fixed size and zero-indexed
  \end{itemize}

  \begin{racket}
#(1 2 3) ; => '#(1 2 3)
(vector-ref '#(1 2 3) 0) ; => 1
  \end{racket}

  \breakcolumn

  \subsubsection{Sets}

  \begin{itemize}
    \item definition: \iracket{set <element> ...}
    \item convert a list to a set: \iracket{list->set}
    \item add an element: \iracket{set-add}
    \item remove an element: \iracket{set-remove}
    \item test if an element is in the set: \iracket{set-member?}
    \item sets don't allow duplicates, are unordered and mutable
    \item methods return a new set instead of changing the original one
  \end{itemize}

  \begin{racket}
(set 1 2 3) ; => '#(1 2 3)
(list->set '(1 2 3)) ; => '#(1 2 3)
(set-add (set 1 2 3) 4) ; => '#(1 2 3 4)
(set-remove (set 1 2 3) 2) ; => '#(1 3)
(set-member? (set 1 2 3) 2) ; => #\t
  \end{racket}

  \subsubsection{Hash}

  \begin{itemize}
    \item definition: \iracket{hash <key> <value> ...}
    \item add a key-value pair: \iracket{hash-set}
    \item remove a key-value pair: \iracket{hash-remove}
    \item get a value from a key: \iracket{hash-ref}
    \item test if a key is in the hash: \iracket{hash-has-key?}
  \end{itemize}

  \begin{racket}
(define (h) (hash 'a 1 'b 2))
(hash-set (h) 'c 3) ; => '#hash((a . 1) (b . 2) (c . 3))
(hash-remove (h) 'b) ; => '#hash((a . 1))
(hash-ref (h) 'a) ; => 1
(hash-has-key? (h) 'a) ; => #\t
  \end{racket}

  \breakcolumn

  \subsection{Control flow}

  \subsubsection{Conditionals}

  \paragraph{if}

  \begin{itemize}
    \item if: \iracket{if <predicate> <then> <else>}
    \item when: \iracket{when <predicate> <then>}
    \item unless: \iracket{unless <predicate> <else>}
  \end{itemize}

  \begin{racket}
(if #\t 1 2) ; => 1
(when #\t 1) ; => 1
(when #\f 1) ; => #<void>
(unless #\t 1) ; => #<void>
(unless #\f 1) ; => 1
  \end{racket}

  \paragraph{cond - case}

  \begin{itemize}
    \item cond: \iracket{cond [<predicate> <then>] ... [<else> <else-then>]}
    \item case: \iracket{case <value> [<case-clause> <then>] ... [<else> <else-then>]}
    \item the \iracket{else} clause is optional
    \item in cond, the value is evaluated against each predicate
    \item in case, the value is evaluated against each clause whose quote is \iracket{eqv?}
  \end{itemize}

  \begin{racket}
(case (+ 7 5)
  [(1 2 3) 'small]
  [(10 11 12) 'big]
  [else 'neither]) ; => 'big
(let ((x 0))
  (cond ((positive? x) 'positive)
  ((negative? x) 'negative)
  (else 'zero))) ; => 'zero
  \end{racket}

  \paragraph{pattern matching}

  \begin{itemize}
    \item match: \iracket{match <value> [<pattern> <then>] ... [_ <else-then>]}
  \end{itemize}

  \begin{racket}
(define (fizzbuzz? n)
  (match (list (remainder n 3) (remainder n 5))
    [(list 0 0) 'fizzbuzz]
    [(list 0 _) 'fizz]
    [(list _ 0) 'buzz]
    [_          #\f]))

(fizzbuzz? 15) ; => 'fizzbuzz
(fizzbuzz? 37) ; => #\f
  \end{racket}

  \breakcolumn

  \subsubsection{Loops}

  \paragraph{when}

  \begin{itemize}
    \item when: \iracket{when <predicate> <then>}
    \item also available as named let
  \end{itemize}

  \begin{racket}
(when #\t (printf "Hello, world!\n")) ; => Hello, world!

(let label ((x 0))      ; initialize x as 0
  (when (< x 10)        ; iterate while x < 10
    (printf "x=~a\n" x) ; print x
    (label (+ x 1))))   ; increment x, go back to label
  \end{racket}

  \paragraph{for}

  \begin{itemize}
    \item for in a range: \iracket{for ([<var> <start> <end>]) <body>}
    \item for over lists: \iracket{for ([<var> <list>]) <body>}
    \item for is available for other collections
  \end{itemize}

  \begin{racket}
(for ([i 10])
  (printf "i=~a\n" i)) ; => i=0, i=1, ...
(for ([i (in-range 5 10)])
  (printf "i=~a\n" i)) ; => i=5, i=6, ...

(for ([i (in-list '(l i s t))])
  (displayln i))

(for ([i (in-vector #(v e c t o r))])
  (displayln i))

(for ([i (in-string "string")])
  (displayln i))

(for ([i (in-set (set 'x 'y 'z))])
  (displayln i))

(for ([(k v) (in-hash (hash 'a 1 'b 2 'c 3))])
  (printf "key:~a value:~a\n" k v))
  \end{racket}

  \breakcolumn

  \subsection{Macros and syntax rules}

  \begin{itemize}
    \item definition: \iracket{define-syntax((<literals>) [(<syntax-rule> ...), ...])}
    \item syntax rules are defined via \iracket{syntax-rules(<pattern> <expansion>)}
    \item macros are expanded at compile time
    \item the \iracket{...} operator indicates repetitions of patterns
    \item the \iracket{_} operator is used to match any syntax object
  \end{itemize}

  \begin{racket}
(define-syntax while
  (syntax-rules ()          ; no reserved keywords
    ((_ condition body ...) ; pattern P
      (let loop ()          ; expansion of P
        (when condition
          ((begin body ...
            (loop))))))))
  \end{racket}

  \subsection{Continuations}

  \begin{itemize}
    \item two ways to call a continuation:
          \begin{itemize}
            \item \iracket{call-with-current-continuation <procedure>}
            \item \iracket{call/cc <procedure>}
          \end{itemize}
    \item saving the continuation: \iracket{save\! <continuation>}
  \end{itemize}

  \subsection{Exceptions}

  \begin{itemize}
    \item exceptions are implemented via continuations
    \item raise an exception: \iracket{raise}
    \item catch an exception: \iracket{with-handlers}
  \end{itemize}

  \begin{racket}
(with-handlers
  ([exn:fail?
    (lambda (e) (printf "error: ~a\n" e))])
  (raise (exn:fail "error message")))
; => error: error message
  \end{racket}

  \breakcolumn

  \subsection{Examples}

  \subsubsection{For via named let}

  \begin{racket}
(define (loop i j)
  (when (< i j)
    (printf "i=~a\n" i)
    (loop (add1 i) j)))
(loop 5 10) ; => i=5, i=6, i=7, i=8, i=9
  \end{racket}

  \subsubsection{Call with current continuation}

  \begin{itemize}
    \item This example shows how to use continuations to implement a break statement via garbage collection strategy
    \item Other strategies are also possible, such as using a stack
  \end{itemize}

  \begin{racket}
; for with break definition
(define-syntax For
  (syntax-rules (from to break : do)
    ((_ var from min to max break : br-sym do body ...)
    (let * ((min1 min)
      (max1 max)
      (inc (if (< min1 max1) + -)))
    (call/cc (lambda (br-sym)
      (let loop ((var min1))
        body ...
        (unless (= var max1)
          (loop (inc var 1))))))))))

; code usage
(For i from 1 to 10 break : get-out
  do (displayln i)
    (when (= i 5)
      (get-out)))
  \end{racket}

\end{multicols*}

\clearpage

\section{Haskell}

\begin{multicols*}{2}

  \subsection{About Nomenclature}

  To avoid further confusion, here is a comparison between Haskell and generic OOP \textit{(object oriented programming)} language nomenclature:

  \begin{itemize}
    \item an OOP \texttt{class} is a Haskell \texttt{interface}
    \item an OOP \texttt{type} is a Haskell \texttt{class}
    \item an OOP \texttt{value} is a Haskell \texttt{object}
    \item an OOP \texttt{method} is a Haskell \texttt{method}
  \end{itemize}

  \subsection{Comments}

  \begin{itemize}
    \item single line comment: \ihaskell{--}
    \item multi-line comment: \ihaskell{\{- ... -\}}

  \end{itemize}

  \begin{haskell}
-- single line comment
{-
  multi-line comment
  can span
  multiple lines
-}
\end{haskell}

  \subsection{Data types}

  \begin{itemize}
    \item data type is inferred automatically by the compiler
    \item data type can be specified explicitly via type annotations \ihaskell{::}
    \item types:
          \begin{itemize}
            \item boolean: \ihaskell{True}, \ihaskell{False}
            \item integer: \ihaskell{1, 2, 3}
            \item float, double: \ihaskell{1.0, 2.0, 3.0}
            \item complex: \ihaskell{1 :+ 2, 2 :+ 3, 3 :+ 4}
            \item character: \ihaskell{'a', 'b', 'c'}
            \item string: \ihaskell{["a", "b", "c"]} or \ihaskell{"abc"}
            \item lists: \ihaskell{[1, 2, 3]}
            \item tuples: \ihaskell{(1, 2, 3)}
          \end{itemize}
  \end{itemize}

  \subsubsection{User defined types}

  \begin{itemize}
    \item sum types: \ihaskell{data <type> = <constructor1> | <constructor2> | ...}
    \item product type: \ihaskell{data <type> = <constructor> <field1> <field2> ...}
  \end{itemize}

  \begin{haskell}
data Bool = True | False -- sum type
data Point = Point Float Float -- product type
\end{haskell}

  \subsubsection{Recursive types}

  \begin{itemize}
    \item syntax: \ihaskell{data <type> = <constructor> <field1> <field2> ... <type>}
  \end{itemize}

  \begin{haskell}
data Tree a = Empty | Node a (Tree a) (Tree a)
\end{haskell}

  \subsubsection{Type Synonyms}

  \begin{itemize}
    \item syntax: \ihaskell{type <name> = <type>}
  \end{itemize}

  \begin{haskell}
type Point = [(Float, Float)]
\end{haskell}

  \subsection{Variables}

  \begin{itemize}
    \item variables are immutable
    \item recursive binding: \ihaskell{let}
    \item declaration with function body: \ihaskell{where}
  \end{itemize}

  \begin{haskell}
let x = 5 in x + 1 -- => 6
let x = 5 y = 2
in x + y -- => 7
f x = x + 1
where x = 5 -- => 6
\end{haskell}

  \subsubsection{Equivalence}

  \begin{itemize}
    \item equivalence between objects, numbers, strings and characters: \ihaskell{==}
  \end{itemize}

  \subsubsection{Basic operations}

  \begin{itemize}
    \item prefix operators can be converted into infix notation via backticks \ihaskell{`<operator>`}
    \item infix operators can be converted into prefix notation via parentheses \ihaskell{(<operator>)}
    \item symbol \ihaskell{\$} is used to avoid parentheses by applying the function to the right first
    \item symbol \ihaskell{.} is used to compose functions
  \end{itemize}

  \breakcolumn

  \paragraph{Operations on numbers}

  \begin{itemize}
    \item arithmetic operations: \ihaskell{+}, \ihaskell{-}, \ihaskell{*}, \ihaskell{/}
    \item exponentiation: \ihaskell{**}
    \item exponentiation by e: \ihaskell{exp}
    \item logarithm: \ihaskell{log}
    \item quotient: \ihaskell{quot}
    \item remainder: \ihaskell{rem}
    \item largest and smallest of two numbers: \ihaskell{max}, \ihaskell{min}
    \item add \(1\): \ihaskell{succ}
    \item subtract \(1\): \ihaskell{pred}
    \item greatest common divisor: \ihaskell{gcd}
    \item least common multiple: \ihaskell{lcm}
  \end{itemize}

  \begin{haskell}
3 + 2 -- => 5
3 - 2 -- => 1
3 * 2 -- => 6
3 / 2 -- => 1.5
3 ** 2 -- => 9.0
exp 2 -- => 7.38905609893065
log 10 -- => 2.302585092994046
quot 5 2 -- => 2
rem 5 2 -- => 1
max 1 2 -- => 2
min 1 2 -- => 1
succ 5 -- => 6
pred 5 -- => 4
gcd 12 18 -- => 6
lcm 12 18 -- => 36
\end{haskell}

  \paragraph{Operations on strings}

  \begin{itemize}
    \item string length: \ihaskell{length}
    \item string append: \ihaskell{++}
    \item string to list: \ihaskell{words}
    \item list to string: \ihaskell{unwords}
  \end{itemize}

  \begin{haskell}
length "Hello, world!" -- => 13
"Hello, " ++ "world!" -- => "Hello, world!"
words "Hello world!" -- => ["Hello", "world!"]
unwords ["Hello", "world!"] -- => "Hello world!"
\end{haskell}

  \breakcolumn

  \paragraph{Operations on bools}

  \begin{itemize}
    \item logic operations: \ihaskell{&&}, \ihaskell{||}, \ihaskell{not}, \ihaskell{xor}
    \item implication: \ihaskell{implies}
  \end{itemize}

  \begin{haskell}
True && False -- => False
True || False -- => True
not True -- => False
xor True False -- => True
implies True False -- => False
\end{haskell}

  \subsection{Functions}

  \begin{itemize}
    \item lambda functions: \ihaskell{\\<name> <arg1> <arg2> ... -> <body>}
    \item functions are defined as sequences of equations
          \begin{itemize}
            \item arguments are matched with the right parts of equations, top to bottom
            \item if the match succeeds, the function body is called
          \end{itemize}
  \end{itemize}

  \begin{haskell}
\x y -> x + y -- => \x y -> x + y
length :: [a] -> Integer -- type annotation
length [] = 0
length (x:xs) = 1 + length xs
1 == 1 -- => True
"abc" == "abc" -- => True
\end{haskell}

  \subsection{Collections}

  \subsubsection{Fields}

  \begin{itemize}
    \item fields can be accessed either by label or by position
  \end{itemize}

  \subsubsection{Lists}

  \begin{itemize}
    \item lists are composed of pairs
    \item manual definition: \ihaskell{[1, 2, 3]}
    \item empty list: \ihaskell{[]}
  \end{itemize}

  \paragraph{Operations on lists}

  \begin{itemize}
    \item list length: \ihaskell{length <list>}
    \item get the reverse of a list: \ihaskell{reverse <list>}
    \item concatenate two lists: \ihaskell{<list1> ++ <list2>}
    \item add an element: \ihaskell{<element> : <list>}
    \item get the first element: \ihaskell{head <list>}
    \item get the last element: \ihaskell{last <list>}
    \item get the n-th element: \ihaskell{<list> \!\! <n>}
    \item get the first n elements: \ihaskell{take <list> <n>}
    \item delete the first \ihaskell{n} elements: \ihaskell{drop <n> <list>}
    \item get all the elements after the first: \ihaskell{tail}
    \item split a list in two: \ihaskell{splitAt <position> <list>}
    \item apply a filter: \ihaskell{filter <predicate> <list>}
    \item apply a function to each element: \ihaskell{map <function> <list>}
    \item sum a list: \ihaskell{sum <list>}
    \item product of a list: \ihaskell{product <list>}
    \item check if a list is empty: \ihaskell{null <list>}
    \item check if an element is in a list: \ihaskell{elem <element> <list>}
    \item check if all elements of a list satisfy a predicate: \ihaskell{all <predicate> <list>}
    \item check if at least one element of a list satisfies a predicate: \ihaskell{any <predicate> <list>}
    \item zip two lists: \ihaskell{zip <list1> <list2>}
  \end{itemize}

  \begin{haskell}
length [1, 2, 3] -- => 3
reverse [1, 2, 3] -- => [3, 2, 1]
[1, 2, 3] ++ [4, 5, 6] -- => [1, 2, 3, 4, 5, 6]
1 : [2, 3] -- => [1, 2, 3]
head [1, 2, 3] -- => 1
last [1, 2, 3] -- => 3
[1, 2, 3] !! 1 -- => 2
take 2 [1, 2, 3] -- => [1, 2]
drop 2 [1, 2, 3] -- => [3]
tail [1, 2, 3] -- => [2, 3]
splitAt 1 [1, 2, 3] -- => ([1], [2, 3])
filter even [1, 2, 3, 4] -- => [2, 4]
map (+1) [1, 2, 3] -- => [2, 3, 4]
sum [1, 2, 3] -- => 6
product [1, 2, 3] -- => 6
null [] -- => True
elem 1 [1, 2, 3] -- => True
all even [2, 4, 6] -- => True
any even [1, 2, 3] -- => True
zip [1, 2, 3] [4, 5, 6] -- => [(1, 4), (2, 5), (3, 6)]
\end{haskell}

  \paragraph{Range notation}

  \begin{itemize}
    \item finite list: \ihaskell{[<start>..<end>]}
    \item finite list with step: \ihaskell{[<start>,<step>..<end>]}
    \item infinite list: \ihaskell{[<start>..]}
    \item infinite list with step: \ihaskell{[<start>,<step>..]}
    \item infinite list with one element repeated: \ihaskell{[<element>,<element>..]}
  \end{itemize}

  To explicitly evaluate a finite list use the \ihaskell{init} function.

  \begin{haskell}
-- all the following instructions are lazily evaluated
[1..10] -- => [1,2,3,4,5,6,7,8,9,10]
[1,3..10] -- => [1,3,5,7,9]
[1..] -- => [1,2,3,4,5,6,7,8,9,10,...]
[1,3..] -- => [1,3,5,7,9,...]
[1,1..] -- => [1,1,1,1,1,1,1,1,1,1,...]
\end{haskell}

  \paragraph{List Comprehension}

  \begin{itemize}
    \item list comprehension returns a list of elements created by evaluation of the generators
    \item syntax: \ihaskell{[<expression> | <generator>, <generator>, ...]}
  \end{itemize}

  \begin{haskell}
[x | x <- [1..10], even x] -- => [2,4,6,8,10]
[x * y | x <- [2,5], y <- [8,10]] -- => [16,20,40,50]
\end{haskell}

  \subsection{Control flow}

  \subsubsection{Pattern matching}

  \begin{itemize}
    \item the matching process is done top to bottom, left to right
    \item patterns may have boolean guards
    \item character \ihaskell{_} matches everything \textit{(don't care)}
  \end{itemize}

  \begin{haskell}
sign x | x > 0 = 1
       | x < 0 = -1
       | otherwise = 0

take 0 _ = []
take _ [] = []
take n (x:xs) = x : take (n - 1) xs
\end{haskell}

  \breakcolumn

  \subsubsection{Case}

  \begin{itemize}
    \item syntax: \ihaskell{case <value> of <pattern> -> <then> ...}
    \item the \ihaskell{_} pattern matches everything
  \end{itemize}

  \begin{haskell}
case x of
  0 -> "zero"
  1 -> "one"
  _ -> "other"
\end{haskell}

  \subsubsection{Conditionals}

  \begin{itemize}
    \item if: \ihaskell{if <predicate> then <then> else <else>}
    \item when: \ihaskell{when <predicate> <then>}
    \item unless: \ihaskell{unless <predicate> <else>}
  \end{itemize}

  \begin{haskell}
if True then 1 else 2 -- => 1
  when True 1 -- => 1
  unless False 1 -- => 1

-- equivalent to
if True then 1 else 2 -- => 1
if True then 1 -- => 1
if False then 1 -- => ()

-- equivalent to
if True then 1 else 2 -- => 1
if False then 2 else 1 -- => 1
\end{haskell}

  \subsubsection{Loops}

  \begin{itemize}
    \item for in a range: \ihaskell{for <var> <- [<start>..<end>] <body>}
    \item for over lists: \ihaskell{for <var> <- <list> <body>}
    \item for is available for other collections
  \end{itemize}

  \begin{haskell}
-- for in a range
for i <- [1..10] do
  print i -- => 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
-- for in a range with condition
for i <- [1..10], i `mod` 2 == 0 do
  print i -- => 2, 4, 6, 8, 10
\end{haskell}

  \breakcolumn

  \subsection{Monads}

  \begin{itemize}
    \item Monads are used to encapsulate side effects
    \item the \ihaskell{do} notation is used to chain monadic actions
  \end{itemize}

  \begin{haskell}
comb :: Maybe a -> (a -> Maybe b) -> Maybe b
comb Nothing _ = Nothing
comb (Just x) f = f x
\end{haskell}

  \subsubsection{Foldable}

  \begin{itemize}
    \item used for folding (either \ihaskell{foldl} or \ihaskell{foldr})
    \item given a container and a binary operation \ihaskell{f}, applies \ihaskell{f} to each element of the container
    \item syntax: \ihaskell{foldr <function> <accumulator> <container>}
  \end{itemize}

  \begin{haskell}
data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)

instance Foldable Tree where
  foldr f z Empty = z
  foldr f z (Leaf x) = f x z
  foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l
\end{haskell}

  \subsubsection{Functor}

  \begin{itemize}
    \item used for mapping (via \ihaskell{fmap})
    \item signature of \ihaskell{fmap}: \ihaskell{fmap :: (a -> b) -> f a -> f b}
  \end{itemize}

  \begin{haskell}
instance Functor Tree where
  fmap f Empty = Empty
  fmap f (Leaf x) = Leaf (f x)
  fmap f (Node l r) = Node (fmap f l) (fmap f r)
\end{haskell}

  \breakcolumn

  \subsubsection{Applicative}

  \begin{itemize}
    \item used for applying a function in a context (via \ihaskell{<*>})
    \item is applied to type constructors that are parametric with one parameter
  \end{itemize}

  \begin{haskell}
instance Applicative Maybe where
  pure x = Just x
  (Just f) <*> something = fmap f something
  Nothing <*> _ = Nothing
\end{haskell}

  \begin{itemize}
    \item \ihaskell{pure} takes a value and returns an applicative (\ihaskell{f}) with that value
    \item \ihaskell{<*>} takes an applicative (\ihaskell{f}) with a function and another applicative (\ihaskell{g}) and returns an applicative (\ihaskell{h}) with the result of applying the function to the value of \ihaskell{g}
  \end{itemize}

  \subsubsection{Monad}

  \begin{itemize}
    \item used for sequencing (via \ihaskell{>>=})
    \item signature of:
          \begin{itemize}
            \item \ihaskell{>>=}: \ihaskell{(>>=) :: m a -> (a -> m b) -> m b}
            \item \ihaskell{>>}: \ihaskell{(>>) :: m a -> m b -> m b}
            \item \ihaskell{return}: \ihaskell{return :: a -> m a}
          \end{itemize}
    \item meaning of:
          \begin{itemize}
            \item \ihaskell{>>=}: \ihaskell{m a} is a monadic action that returns a value of type \ihaskell{a}
            \item \ihaskell{f} is a function that takes a value of type \ihaskell{a} and returns a monadic action that returns a value of type \ihaskell{b}
            \item \ihaskell{>>=} returns a monadic action that returns a value of type \ihaskell{b}
          \end{itemize}
    \item \ihaskell{do} notation is used to chain monadic actions, it is translated into \ihaskell{>>=} and \ihaskell{>>}
    \item \ihaskell{do} notation is available for all monads
  \end{itemize}

  \begin{haskell}
instance Monad Maybe where
  return = Just
  Nothing >>= _ = Nothing
  (Just x) >>= f = f x
\end{haskell}

  \breakcolumn

  \subsection{Type classes}

  \begin{itemize}
    \item type classes are defined via \ihaskell{class}
    \item type classes are instantiated via \ihaskell{instance}
  \end{itemize}

  \subsubsection{Polymorphism}

  \begin{itemize}
    \item type class constraints are resolved at compile time
    \item parametric polymorphism: \ihaskell{<name> :: <type> -> <type>}
    \item ad-hoc polymorphism: \ihaskell{<name> :: <type class> => <type> -> <type>}
  \end{itemize}

  \begin{haskell}
-- parametric polymorphism
id :: a -> a
id x = x

-- ad-hoc polymorphism
(+) :: Num a => a -> a -> a
x + y = x + y
\end{haskell}

  \breakcolumn

  \subsection{Examples}

  \subsubsection{Tree}

  \begin{haskell}
-- define a tree
data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show, Eq)

-- make tree instance of foldable
instance Foldable Tree where
  foldr f z Empty = z
  foldr f z (Node x l r) = foldr f (f x (foldr f z r)) l

-- make tree instance of functor
instance Functor Tree where
  fmap f Empty = Empty
  fmap f (Node x l r) = Node (f x) (fmap f l) (fmap f r)

-- make tree instance of applicative
instance Applicative Tree where
  pure x = Node x Empty Empty
  Empty <*> _ = Empty
  _ <*> Empty = Empty
  (Node x l r) <*> (Node x' l' r') = Node (f x) (l <*> l') (r <*> r')

-- make tree instance of monad
instance Monad Tree where
  return x = Node x Empty Empty
  fail _ = Empty
  Empty >>= _ = Empty
  (Node x l r) >>= f = Node x (l >>= f) (r >>= f)

-- make tree instance of equality
  instance Eq a => Eq (Tree a) where
  Empty == Empty = True
  (Node x l r) == (Node y l' r') = x == y && l == l' && r == r'
  _ == _ = False

-- make tree instance of show
  instance Show a => Show (Tree a) where
  show Empty = "Empty"
  show (Node x l r) = "Node " ++ show x ++ " (" ++ show l ++ ") (" ++ show r ++ ")"
\end{haskell}

  \begin{haskell}
-- example usage of the tree monad
-- tree with 1 as root and 2 as left child
-- and 3 as right child
tree = Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty)

-- tree with 1 as root and 2 as left child
-- and 3 as right child
tree' = do
  x <- return 1
  l <- return (Node 2 Empty Empty)
  r <- return (Node 3 Empty Empty)
  return (Node x l r)
  \end{haskell}

\end{multicols*}

\clearpage

\begin{multicols*}{2}

  \section{Erlang}

  \subsection{Syntax}

  \begin{itemize}
    \item period \ierlang{.} terminates expressions
    \item semicolon \ierlang{;} separates expressions branches and clauses
    \item comma \ierlang{,} separates alternate clauses
  \end{itemize}

  \subsection{Comments}

  \begin{itemize}
    \item single line comment: \ierlang{\%}
    \item multi line comments are not supported
  \end{itemize}

  \begin{erlang}
% single line comment
%% sometimes the double percent is used
%% no multi line comment support
\end{erlang}

  \subsection{Data types}

  \begin{itemize}
    \item term: any Erlang data
    \item integer: \ierlang{1, 2, 3}
    \item float: \ierlang{1.0, 2.0, 3.0}
    \item binary, hexadecimal and octal numbers: \ierlang{2#101, 16#FF, 8#377}
    \item atoms: \ierlang{atom} \textit{(see \ref{sec:erlang-atoms})}
    \item bit strings: \ierlang{<<"hello">>}
    \item strings: \ierlang{"hello"}
  \end{itemize}

  \subsubsection{Atoms}
  \label{sec:erlang-atoms}

  \begin{itemize}
    \item any sequence of letters, digits, underscore, at sign, dollar sign and full stop
    \item atoms are used to represent constants
    \item syntax: \ierlang{atom} or \ierlang{'atom'}
    \item if unquoted, atoms can contain only lowercase letters, digits and underscore
  \end{itemize}

  \begin{erlang}
atom   % => atom
'atom' % => atom
'ATOM' % => 'ATOM'
\end{erlang}

  \columnbreak

  \subsection{Functions}

  \begin{itemize}
    \item functions are defined as sequences of equations
          \begin{itemize}
            \item arguments are matched with the right parts of equations, top to bottom
            \item if the match succeeds, the function body is called
          \end{itemize}
    \item functions have boolean guards \ierlang{when <predicate> -> <then>}
          \begin{itemize}
            \item guards are evaluated in constant time
          \end{itemize}
  \end{itemize}

  \begin{erlang}
factorial(0) -> 1;
factorial(N) when N > 0 -> N * factorial(N - 1).
\end{erlang}

  \subsubsection{Apply}

  \begin{itemize}
    \item syntax: \ierlang{apply(<module>, <function>, <arguments>)}
    \item any expression can be used as a function
    \item the function is applied to the arguments
    \item \ierlang{?MODULE} is a macro that expands to the name of the current module
  \end{itemize}

  \begin{erlang}
% assumption:factorial is defined in the current module
apply(?MODULE, factorial, [5]) % => 120
\end{erlang}

  \subsubsection{Function Guards}

  \begin{itemize}
    \item \ierlang{X} is a number: \ierlang{is_number(X)}
    \item \ierlang{X} is an integer: \ierlang{is_integer(X)}
    \item \ierlang{X} is a float: \ierlang{is_float(X)}
    \item \ierlang{X} is an atom: \ierlang{is_atom(X)}
    \item \ierlang{X} is a list: \ierlang{is_list(X)}
    \item \ierlang{X} is a tuple: \ierlang{is_tuple(X)}
    \item \ierlang{X} is a map: \ierlang{is_map(X)}
    \item \ierlang{X} is greater than \ierlang{Y}: \ierlang{X > Y}
    \item \ierlang{X} is less than \ierlang{Y}: \ierlang{X < Y}
    \item \ierlang{X} is exactly equal to \ierlang{Y}: \ierlang{X =:= Y}
    \item \ierlang{X} is equal to \ierlang{Y} when converted to the \texttt{int}: \ierlang{X == Y}
    \item \ierlang{X} is not equal to \ierlang{Y}: \ierlang{X =/= Y}
    \item \ierlang{X} is a list of length \ierlang{N}: \ierlang{length(X) =:= N}
    \item \ierlang{X} is a tuple of length \ierlang{N}: \ierlang{size(X) =:= N}
  \end{itemize}

  \breakcolumn

  \subsubsection{Function Calls}

  \begin{itemize}
    \item function and modules names must be atoms
    \item function call \ierlang{<name>(<arg1>, <arg2>, ...)}
    \item alternative \ierlang{<module>:<name>(<arg1>, <arg2>, ...)}
    \item use \ierlang{-import} to avoid specifying the module name
  \end{itemize}

  \begin{erlang}
my_module:my_function(1, 2, 3) % => 6
-import(my_module, [my_function/3]).
my_function(1, 2, 3) % => 6
\end{erlang}

  \subsection{Variables}

  \begin{itemize}
    \item variables are immutable and can be bound only once
    \item variables start with an uppercase letter
    \item there is no keyword for variable declaration
  \end{itemize}

  \begin{erlang}
X = 5 % => X = 5
Long_variable_name = 5 % => Long_variable_name = 5
\end{erlang}

  \subsection{Collections}

  \subsubsection{Lists}

  \begin{itemize}
    \item lists are composed of pairs
    \item lists are immutable
    \item manual definition: \ierlang{[1, 2, 3]}
    \item empty list: \ierlang{[]}
  \end{itemize}

  \begin{erlang}
[1, 2, 3] % => [1, 2, 3]
[1, [2, 3]] % => [1, [2, 3]]
\end{erlang}

  \breakcolumn

  \paragraph{Operations on lists}

  \begin{itemize}
    \item list length: \ierlang{length(<list>)}
    \item add an element at the beginning: \ierlang{[<element> | <list>]}
    \item add an element at the end: \ierlang{<list> ++ [<element>]}
    \item get the first element: \ierlang{lists:first(<list>)}
    \item get the last element: \ierlang{lists:last(<list>)}
    \item get the n-th element: \ierlang{lists:nth(<position>, <list>)}
    \item get the first n elements: \ierlang{lists:sublist(<list>, 0, <n>)}
    \item append two lists: \ierlang{lists:append(<list1>, <list2>)}
    \item concatenate two lists: \ierlang{<list1> ++ <list2>}

    \item delete the first occurrence of an element: \ierlang{lists:delete(<element>, <list>)}
    \item delete the last element of a list: \ierlang{lists:droplast(<list>)}
    \item delete the first element of a list: \ierlang{lists:drop(<list>)}
    \item apply a filter: \ierlang{lists:filter(<predicate>, <list>)}
    \item flatten a list: \ierlang{lists:flatten(<list>)}

    \item call a function on each element: \ierlang{lists:foreach(<function>, <list>)}
    \item map a function on each element: \ierlang{lists:map(<function>, <list>)}
    \item find the maximum element: \ierlang{lists:max(<list>)}
    \item find the minimum element: \ierlang{lists:min(<list>)}
  \end{itemize}

  \paragraph{Lists folding}

  \begin{itemize}
    \item fold a list from the left: \ierlang{lists:foldl(<function>, <accumulator>, <list>)}
    \item fold a list from the right: \ierlang{lists:foldr(<function>, <accumulator>, <list>)}
  \end{itemize}

  \begin{erlang}
lists:foldl(fun(X, Acc) -> X + Acc end, 0, [1, 2, 3]) % => 6
lists:foldr(fun(X, Acc) -> X + Acc end, 0, [1, 2, 3]) % => 6
\end{erlang}

  \subsubsection{Tuples}

  \begin{itemize}
    \item tuples are immutable
    \item tuples can be nested
    \item syntax: \ierlang{\{<element1>, <element2>, ...\}}
  \end{itemize}

  \begin{erlang}
{1, 2, 3} % => {1, 2, 3}
{1, {2, 3}} % => {1, {2, 3}}
\end{erlang}

  \breakcolumn

  \subsubsection{Records}

  \begin{itemize}
    \item records are tuples with named fields
    \item records are defined via \ierlang{-record(<name>, {<field1>, <field2>, ...})}
    \item records are accessed via \ierlang{#<name>.<field>}
  \end{itemize}

  \begin{erlang}
-record(point, {x, y}).
#point.x % => x
\end{erlang}

  \subsubsection{Maps}

  \begin{itemize}
    \item maps are defined via \ierlang{\#{<key> => <value>, <key> => <value>, ...}}
    \item keys are accessed via \ierlang{<map>.<key>}
    \item maps are updated:
          \begin{itemize}
            \item to add or overwrite a key-value pair: \ierlang{<map>#{<key> => <value>}}
            \item to only update an existing key-value pair: \ierlang{<map>#{<key> := <value>}}
          \end{itemize}
  \end{itemize}

  \begin{erlang}
Map = #{a => 1, b => 2} % => #{a => 1, b => 2}
Map#{c => 3} % => #{a => 1, b => 2, c => 3}
Map#{a := 2} % => #{a => 2, b => 2}
Map#{d := 4} % => error
\end{erlang}

  \subsection{Control flow}

  \subsubsection{Conditionals}

  \paragraph{Pattern matching}

  \begin{itemize}
    \item the matching process is done top to bottom, left to right
    \item patterns may have boolean guards
    \item character \ierlang{_} matches everything \textit{(don't care)}
  \end{itemize}

  \begin{erlang}
sign(X) when X > 0 -> 1;
sign(X) when X < 0 -> -1;
sign(_) -> 0.
\end{erlang}

  \breakcolumn

  \paragraph{if}

  \begin{itemize}
    \item syntax: \ierlang{if <predicate> -> <then>; <predicate> -> <then>; ... end}
    \item the \ierlang{true} pattern matches everything
    \item function guards are necessary
  \end{itemize}

  \begin{erlang}
if
  is_integer(X) -> integer_to_list(X);
  is_float(X) -> float_to_list(X);
  true -> "error" % this is the default case
end.
\end{erlang}

  \paragraph{case}

  \begin{itemize}
    \item syntax: \ierlang{case <value> of <pattern> -> <then>; <pattern> -> <then>; ... end}
    \item the \ierlang{true} pattern matches everything
    \item function guards are not required
  \end{itemize}

  \begin{erlang}
case X of
  0 -> "zero";
  1 -> "one";
  true -> "other"
end.
\end{erlang}

  \subsubsection{Loops}

  \begin{itemize}
    \item loops must be implemented via recursion
  \end{itemize}

  \paragraph{while}

  \begin{itemize}
    \item syntax: \ierlang{while(<predicate>) -> <then>; ...}
  \end{itemize}

  \begin{erlang}
while(X) ->
  if
    X > 0 ->
      io:format("~p~n", [X]),
      while(X - 1);
    true ->
      ok.
end.
\end{erlang}

  \breakcolumn

  \paragraph{for}

  \begin{itemize}
    \item syntax: \ierlang{for(<variable>) -> <then>; ...}
  \end{itemize}

  \begin{erlang}
for(X) ->
  for(X, 0).

for(X, N) when N < X ->
  io:format("~p~n", [N]),
  for(X, N + 1).

for(_, _) ->
  ok.
  \end{erlang}

  \subsection{Concurrent programming}

  \begin{itemize}
    \item processes are created via \ierlang{spawn(<module>, <function>, <arguments>)}
    \item processes are identified via \ierlang{Pid}
    \item messages are sent via \ierlang{Pid \! <message>}
    \item messages are received via \ierlang{receive <pattern> -> <then>; ... end}
  \end{itemize}

  \breakcolumn

  \subsection{Examples}

  \subsubsection{Echo process}

  \begin{erlang}
-module(echo).
-export([start/0, loop/0]).

start() ->
  Pid2 = spawn(echo, loop, []),
  Pid2 ! {self(), hello},

  receive
    {Pid2, Msg} -> io:format("received ~p~n", [Msg])
  end.

Pid2 ! stop.

loop() ->
  receive
    {From, Msg} ->
      From ! {self(), Msg},
    loop();
    stop ->
      true
  end.
\end{erlang}

  \breakcolumn

  \subsubsection{Client-server}

  \begin{itemize}
    \item requests have syntax \ierlang{\{request, <data>\}}
    \item responses have syntax \ierlang{\{response, <data>\}}
    \item note: both server and client run on the same machine; there's no actual way to communicate between different machines
  \end{itemize}

  \begin{erlang}
%% server code
server(Data) ->
  receive
    {From, {request, X}} ->
      {R, Data1} = handle(X, Data),
      % note: handle function is defined elsewhere
      From ! {my_server, {response, R}},
      server(Data1);
    {From, stop} ->
      From ! {my_server, stopped}
  end.

%% client code
client(Server) ->
  Server ! {self(), {request, 1}},
  receive
    {my_server, {response, R}} ->
      io:format("received ~p~n", [R])
  end.

client(Server) ->
  Server ! {self(), stop},
  receive
    {my_server, stopped} -> ok
  end.

start() ->
  Server = spawn(?MODULE, server, []),
  spawn(?MODULE, client, [Server]).
\end{erlang}

  \columnbreak

  \subsubsection{Catching errors}

  \begin{erlang}

  divide(X, Y) ->
    {ok, X / Y}.

  main() ->
    process_flag(trap_exit, true), % catch exit signals
    Pid = spawn(fun() -> divide(1, 0) end),
    receive
      {'EXIT', Pid, Reason} -> % catch exit signal
        io:format("error: ~p,~p~n", [Pid, Reason]);
      {result, _, normal} ->  % catch normal exit
        io:format("result: ~p~n", [Result]);
    end.
\end{erlang}

\end{multicols*}

\clearpage

\section{Latest version, Contributions, Credits and License}

\subsection{Latest version and Contributions}

This document has been compiled on \today;
the latest version is available at \url{https://github.com/lorossi/principles-of-programming-languages-reference}.

If you see any error, want to contribute or have any suggestion, feel free to open an issue or a pull request there!
I tried very hard to keep consistency between the three languages, but managing different syntaxes and features is not easy.
I also tried to run every bit of code, making sure that it works as expected, but I may have missed something.

\bigskip

\subsection{Credits}

Some of the examples of the code are taken from the slides and the lessons of \textit{Principles of Programming Languages} course by Prof. Matteo Pradella, Politecnico di Milano, A.Y. 2023/2024.
Likewise, some of the snippets in the repository are taken from his exams and their solutions.

\smallskip

The font used in this document is \textit{Roboto Light Condensed}, available at \url{https://fonts.google.com/specimen/Roboto}.

\bigskip

\subsection{License}

The content of this document is licensed under the Creative Commons Attribution-ShareAlike 4.0 International License.
\ccbync

To view a copy of this license, visit \url{https://creativecommons.org/licenses/by-nc/4.0/}.

\smallskip

All the source code in this document and the snippets included in the repository are licensed under the MIT License.

To view a copy of this license, visit \url{https://opensource.org/licenses/MIT}.

\end{document}